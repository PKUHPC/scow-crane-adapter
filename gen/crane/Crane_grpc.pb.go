//*
// Copyright (c) 2024 Peking University and Peking University
// Changsha Institute for Computing and Digital Economy
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: Crane.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CraneCtld_CancelTask_FullMethodName             = "/crane.grpc.CraneCtld/CancelTask"
	CraneCtld_SubmitBatchTask_FullMethodName        = "/crane.grpc.CraneCtld/SubmitBatchTask"
	CraneCtld_SubmitBatchTasks_FullMethodName       = "/crane.grpc.CraneCtld/SubmitBatchTasks"
	CraneCtld_QueryCranedInfo_FullMethodName        = "/crane.grpc.CraneCtld/QueryCranedInfo"
	CraneCtld_QueryPartitionInfo_FullMethodName     = "/crane.grpc.CraneCtld/QueryPartitionInfo"
	CraneCtld_QueryReservationInfo_FullMethodName   = "/crane.grpc.CraneCtld/QueryReservationInfo"
	CraneCtld_ModifyTask_FullMethodName             = "/crane.grpc.CraneCtld/ModifyTask"
	CraneCtld_ModifyNode_FullMethodName             = "/crane.grpc.CraneCtld/ModifyNode"
	CraneCtld_ModifyPartitionAcl_FullMethodName     = "/crane.grpc.CraneCtld/ModifyPartitionAcl"
	CraneCtld_EnableAutoPowerControl_FullMethodName = "/crane.grpc.CraneCtld/EnableAutoPowerControl"
	CraneCtld_AddAccount_FullMethodName             = "/crane.grpc.CraneCtld/AddAccount"
	CraneCtld_AddUser_FullMethodName                = "/crane.grpc.CraneCtld/AddUser"
	CraneCtld_AddQos_FullMethodName                 = "/crane.grpc.CraneCtld/AddQos"
	CraneCtld_DeleteAccount_FullMethodName          = "/crane.grpc.CraneCtld/DeleteAccount"
	CraneCtld_DeleteUser_FullMethodName             = "/crane.grpc.CraneCtld/DeleteUser"
	CraneCtld_DeleteQos_FullMethodName              = "/crane.grpc.CraneCtld/DeleteQos"
	CraneCtld_QueryAccountInfo_FullMethodName       = "/crane.grpc.CraneCtld/QueryAccountInfo"
	CraneCtld_QueryUserInfo_FullMethodName          = "/crane.grpc.CraneCtld/QueryUserInfo"
	CraneCtld_QueryQosInfo_FullMethodName           = "/crane.grpc.CraneCtld/QueryQosInfo"
	CraneCtld_ModifyAccount_FullMethodName          = "/crane.grpc.CraneCtld/ModifyAccount"
	CraneCtld_ModifyUser_FullMethodName             = "/crane.grpc.CraneCtld/ModifyUser"
	CraneCtld_ModifyQos_FullMethodName              = "/crane.grpc.CraneCtld/ModifyQos"
	CraneCtld_BlockAccountOrUser_FullMethodName     = "/crane.grpc.CraneCtld/BlockAccountOrUser"
	CraneCtld_QueryClusterInfo_FullMethodName       = "/crane.grpc.CraneCtld/QueryClusterInfo"
	CraneCtld_QueryTasksInfo_FullMethodName         = "/crane.grpc.CraneCtld/QueryTasksInfo"
	CraneCtld_CreateReservation_FullMethodName      = "/crane.grpc.CraneCtld/CreateReservation"
	CraneCtld_DeleteReservation_FullMethodName      = "/crane.grpc.CraneCtld/DeleteReservation"
	CraneCtld_PowerStateChange_FullMethodName       = "/crane.grpc.CraneCtld/PowerStateChange"
)

// CraneCtldClient is the client API for CraneCtld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Todo: Divide service into two parts: one for Craned and one for Crun
//
//	We need to distinguish the message sender
//	and have some kind of authentication
type CraneCtldClient interface {
	// RPCs called from ccancel
	CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskReply, error)
	// RPCs called from cbatch
	SubmitBatchTask(ctx context.Context, in *SubmitBatchTaskRequest, opts ...grpc.CallOption) (*SubmitBatchTaskReply, error)
	SubmitBatchTasks(ctx context.Context, in *SubmitBatchTasksRequest, opts ...grpc.CallOption) (*SubmitBatchTasksReply, error)
	// PRCs called from ccontrol
	QueryCranedInfo(ctx context.Context, in *QueryCranedInfoRequest, opts ...grpc.CallOption) (*QueryCranedInfoReply, error)
	QueryPartitionInfo(ctx context.Context, in *QueryPartitionInfoRequest, opts ...grpc.CallOption) (*QueryPartitionInfoReply, error)
	QueryReservationInfo(ctx context.Context, in *QueryReservationInfoRequest, opts ...grpc.CallOption) (*QueryReservationInfoReply, error)
	ModifyTask(ctx context.Context, in *ModifyTaskRequest, opts ...grpc.CallOption) (*ModifyTaskReply, error)
	ModifyNode(ctx context.Context, in *ModifyCranedStateRequest, opts ...grpc.CallOption) (*ModifyCranedStateReply, error)
	ModifyPartitionAcl(ctx context.Context, in *ModifyPartitionAclRequest, opts ...grpc.CallOption) (*ModifyPartitionAclReply, error)
	EnableAutoPowerControl(ctx context.Context, in *EnableAutoPowerControlRequest, opts ...grpc.CallOption) (*EnableAutoPowerControlReply, error)
	// RPCs called from cacctmgr
	AddAccount(ctx context.Context, in *AddAccountRequest, opts ...grpc.CallOption) (*AddAccountReply, error)
	AddUser(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserReply, error)
	AddQos(ctx context.Context, in *AddQosRequest, opts ...grpc.CallOption) (*AddQosReply, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountReply, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserReply, error)
	DeleteQos(ctx context.Context, in *DeleteQosRequest, opts ...grpc.CallOption) (*DeleteQosReply, error)
	QueryAccountInfo(ctx context.Context, in *QueryAccountInfoRequest, opts ...grpc.CallOption) (*QueryAccountInfoReply, error)
	QueryUserInfo(ctx context.Context, in *QueryUserInfoRequest, opts ...grpc.CallOption) (*QueryUserInfoReply, error)
	QueryQosInfo(ctx context.Context, in *QueryQosInfoRequest, opts ...grpc.CallOption) (*QueryQosInfoReply, error)
	ModifyAccount(ctx context.Context, in *ModifyAccountRequest, opts ...grpc.CallOption) (*ModifyAccountReply, error)
	ModifyUser(ctx context.Context, in *ModifyUserRequest, opts ...grpc.CallOption) (*ModifyUserReply, error)
	ModifyQos(ctx context.Context, in *ModifyQosRequest, opts ...grpc.CallOption) (*ModifyQosReply, error)
	BlockAccountOrUser(ctx context.Context, in *BlockAccountOrUserRequest, opts ...grpc.CallOption) (*BlockAccountOrUserReply, error)
	// RPCs called from cinfo
	QueryClusterInfo(ctx context.Context, in *QueryClusterInfoRequest, opts ...grpc.CallOption) (*QueryClusterInfoReply, error)
	// common RPCs
	QueryTasksInfo(ctx context.Context, in *QueryTasksInfoRequest, opts ...grpc.CallOption) (*QueryTasksInfoReply, error)
	CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*CreateReservationReply, error)
	DeleteReservation(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*DeleteReservationReply, error)
	// RPC called form plugin
	PowerStateChange(ctx context.Context, in *PowerStateChangeRequest, opts ...grpc.CallOption) (*PowerStateChangeReply, error)
}

type craneCtldClient struct {
	cc grpc.ClientConnInterface
}

func NewCraneCtldClient(cc grpc.ClientConnInterface) CraneCtldClient {
	return &craneCtldClient{cc}
}

func (c *craneCtldClient) CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelTaskReply)
	err := c.cc.Invoke(ctx, CraneCtld_CancelTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) SubmitBatchTask(ctx context.Context, in *SubmitBatchTaskRequest, opts ...grpc.CallOption) (*SubmitBatchTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBatchTaskReply)
	err := c.cc.Invoke(ctx, CraneCtld_SubmitBatchTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) SubmitBatchTasks(ctx context.Context, in *SubmitBatchTasksRequest, opts ...grpc.CallOption) (*SubmitBatchTasksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBatchTasksReply)
	err := c.cc.Invoke(ctx, CraneCtld_SubmitBatchTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryCranedInfo(ctx context.Context, in *QueryCranedInfoRequest, opts ...grpc.CallOption) (*QueryCranedInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryCranedInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryCranedInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryPartitionInfo(ctx context.Context, in *QueryPartitionInfoRequest, opts ...grpc.CallOption) (*QueryPartitionInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPartitionInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryPartitionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryReservationInfo(ctx context.Context, in *QueryReservationInfoRequest, opts ...grpc.CallOption) (*QueryReservationInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryReservationInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryReservationInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyTask(ctx context.Context, in *ModifyTaskRequest, opts ...grpc.CallOption) (*ModifyTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyTaskReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyNode(ctx context.Context, in *ModifyCranedStateRequest, opts ...grpc.CallOption) (*ModifyCranedStateReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyCranedStateReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyPartitionAcl(ctx context.Context, in *ModifyPartitionAclRequest, opts ...grpc.CallOption) (*ModifyPartitionAclReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyPartitionAclReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyPartitionAcl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) EnableAutoPowerControl(ctx context.Context, in *EnableAutoPowerControlRequest, opts ...grpc.CallOption) (*EnableAutoPowerControlReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableAutoPowerControlReply)
	err := c.cc.Invoke(ctx, CraneCtld_EnableAutoPowerControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) AddAccount(ctx context.Context, in *AddAccountRequest, opts ...grpc.CallOption) (*AddAccountReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddAccountReply)
	err := c.cc.Invoke(ctx, CraneCtld_AddAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) AddUser(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_AddUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) AddQos(ctx context.Context, in *AddQosRequest, opts ...grpc.CallOption) (*AddQosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddQosReply)
	err := c.cc.Invoke(ctx, CraneCtld_AddQos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAccountReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteQos(ctx context.Context, in *DeleteQosRequest, opts ...grpc.CallOption) (*DeleteQosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteQosReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteQos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryAccountInfo(ctx context.Context, in *QueryAccountInfoRequest, opts ...grpc.CallOption) (*QueryAccountInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAccountInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryAccountInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryUserInfo(ctx context.Context, in *QueryUserInfoRequest, opts ...grpc.CallOption) (*QueryUserInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUserInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryQosInfo(ctx context.Context, in *QueryQosInfoRequest, opts ...grpc.CallOption) (*QueryQosInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryQosInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryQosInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyAccount(ctx context.Context, in *ModifyAccountRequest, opts ...grpc.CallOption) (*ModifyAccountReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyAccountReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyUser(ctx context.Context, in *ModifyUserRequest, opts ...grpc.CallOption) (*ModifyUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyQos(ctx context.Context, in *ModifyQosRequest, opts ...grpc.CallOption) (*ModifyQosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyQosReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyQos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) BlockAccountOrUser(ctx context.Context, in *BlockAccountOrUserRequest, opts ...grpc.CallOption) (*BlockAccountOrUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockAccountOrUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_BlockAccountOrUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryClusterInfo(ctx context.Context, in *QueryClusterInfoRequest, opts ...grpc.CallOption) (*QueryClusterInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryClusterInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryTasksInfo(ctx context.Context, in *QueryTasksInfoRequest, opts ...grpc.CallOption) (*QueryTasksInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTasksInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryTasksInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*CreateReservationReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReservationReply)
	err := c.cc.Invoke(ctx, CraneCtld_CreateReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteReservation(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*DeleteReservationReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteReservationReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) PowerStateChange(ctx context.Context, in *PowerStateChangeRequest, opts ...grpc.CallOption) (*PowerStateChangeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PowerStateChangeReply)
	err := c.cc.Invoke(ctx, CraneCtld_PowerStateChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CraneCtldServer is the server API for CraneCtld service.
// All implementations should embed UnimplementedCraneCtldServer
// for forward compatibility.
//
// Todo: Divide service into two parts: one for Craned and one for Crun
//
//	We need to distinguish the message sender
//	and have some kind of authentication
type CraneCtldServer interface {
	// RPCs called from ccancel
	CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskReply, error)
	// RPCs called from cbatch
	SubmitBatchTask(context.Context, *SubmitBatchTaskRequest) (*SubmitBatchTaskReply, error)
	SubmitBatchTasks(context.Context, *SubmitBatchTasksRequest) (*SubmitBatchTasksReply, error)
	// PRCs called from ccontrol
	QueryCranedInfo(context.Context, *QueryCranedInfoRequest) (*QueryCranedInfoReply, error)
	QueryPartitionInfo(context.Context, *QueryPartitionInfoRequest) (*QueryPartitionInfoReply, error)
	QueryReservationInfo(context.Context, *QueryReservationInfoRequest) (*QueryReservationInfoReply, error)
	ModifyTask(context.Context, *ModifyTaskRequest) (*ModifyTaskReply, error)
	ModifyNode(context.Context, *ModifyCranedStateRequest) (*ModifyCranedStateReply, error)
	ModifyPartitionAcl(context.Context, *ModifyPartitionAclRequest) (*ModifyPartitionAclReply, error)
	EnableAutoPowerControl(context.Context, *EnableAutoPowerControlRequest) (*EnableAutoPowerControlReply, error)
	// RPCs called from cacctmgr
	AddAccount(context.Context, *AddAccountRequest) (*AddAccountReply, error)
	AddUser(context.Context, *AddUserRequest) (*AddUserReply, error)
	AddQos(context.Context, *AddQosRequest) (*AddQosReply, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountReply, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserReply, error)
	DeleteQos(context.Context, *DeleteQosRequest) (*DeleteQosReply, error)
	QueryAccountInfo(context.Context, *QueryAccountInfoRequest) (*QueryAccountInfoReply, error)
	QueryUserInfo(context.Context, *QueryUserInfoRequest) (*QueryUserInfoReply, error)
	QueryQosInfo(context.Context, *QueryQosInfoRequest) (*QueryQosInfoReply, error)
	ModifyAccount(context.Context, *ModifyAccountRequest) (*ModifyAccountReply, error)
	ModifyUser(context.Context, *ModifyUserRequest) (*ModifyUserReply, error)
	ModifyQos(context.Context, *ModifyQosRequest) (*ModifyQosReply, error)
	BlockAccountOrUser(context.Context, *BlockAccountOrUserRequest) (*BlockAccountOrUserReply, error)
	// RPCs called from cinfo
	QueryClusterInfo(context.Context, *QueryClusterInfoRequest) (*QueryClusterInfoReply, error)
	// common RPCs
	QueryTasksInfo(context.Context, *QueryTasksInfoRequest) (*QueryTasksInfoReply, error)
	CreateReservation(context.Context, *CreateReservationRequest) (*CreateReservationReply, error)
	DeleteReservation(context.Context, *DeleteReservationRequest) (*DeleteReservationReply, error)
	// RPC called form plugin
	PowerStateChange(context.Context, *PowerStateChangeRequest) (*PowerStateChangeReply, error)
}

// UnimplementedCraneCtldServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCraneCtldServer struct{}

func (UnimplementedCraneCtldServer) CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTask not implemented")
}
func (UnimplementedCraneCtldServer) SubmitBatchTask(context.Context, *SubmitBatchTaskRequest) (*SubmitBatchTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatchTask not implemented")
}
func (UnimplementedCraneCtldServer) SubmitBatchTasks(context.Context, *SubmitBatchTasksRequest) (*SubmitBatchTasksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatchTasks not implemented")
}
func (UnimplementedCraneCtldServer) QueryCranedInfo(context.Context, *QueryCranedInfoRequest) (*QueryCranedInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCranedInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryPartitionInfo(context.Context, *QueryPartitionInfoRequest) (*QueryPartitionInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPartitionInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryReservationInfo(context.Context, *QueryReservationInfoRequest) (*QueryReservationInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReservationInfo not implemented")
}
func (UnimplementedCraneCtldServer) ModifyTask(context.Context, *ModifyTaskRequest) (*ModifyTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyTask not implemented")
}
func (UnimplementedCraneCtldServer) ModifyNode(context.Context, *ModifyCranedStateRequest) (*ModifyCranedStateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyNode not implemented")
}
func (UnimplementedCraneCtldServer) ModifyPartitionAcl(context.Context, *ModifyPartitionAclRequest) (*ModifyPartitionAclReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyPartitionAcl not implemented")
}
func (UnimplementedCraneCtldServer) EnableAutoPowerControl(context.Context, *EnableAutoPowerControlRequest) (*EnableAutoPowerControlReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableAutoPowerControl not implemented")
}
func (UnimplementedCraneCtldServer) AddAccount(context.Context, *AddAccountRequest) (*AddAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAccount not implemented")
}
func (UnimplementedCraneCtldServer) AddUser(context.Context, *AddUserRequest) (*AddUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUser not implemented")
}
func (UnimplementedCraneCtldServer) AddQos(context.Context, *AddQosRequest) (*AddQosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddQos not implemented")
}
func (UnimplementedCraneCtldServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedCraneCtldServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedCraneCtldServer) DeleteQos(context.Context, *DeleteQosRequest) (*DeleteQosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQos not implemented")
}
func (UnimplementedCraneCtldServer) QueryAccountInfo(context.Context, *QueryAccountInfoRequest) (*QueryAccountInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAccountInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryUserInfo(context.Context, *QueryUserInfoRequest) (*QueryUserInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryQosInfo(context.Context, *QueryQosInfoRequest) (*QueryQosInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryQosInfo not implemented")
}
func (UnimplementedCraneCtldServer) ModifyAccount(context.Context, *ModifyAccountRequest) (*ModifyAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyAccount not implemented")
}
func (UnimplementedCraneCtldServer) ModifyUser(context.Context, *ModifyUserRequest) (*ModifyUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyUser not implemented")
}
func (UnimplementedCraneCtldServer) ModifyQos(context.Context, *ModifyQosRequest) (*ModifyQosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyQos not implemented")
}
func (UnimplementedCraneCtldServer) BlockAccountOrUser(context.Context, *BlockAccountOrUserRequest) (*BlockAccountOrUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockAccountOrUser not implemented")
}
func (UnimplementedCraneCtldServer) QueryClusterInfo(context.Context, *QueryClusterInfoRequest) (*QueryClusterInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryClusterInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryTasksInfo(context.Context, *QueryTasksInfoRequest) (*QueryTasksInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTasksInfo not implemented")
}
func (UnimplementedCraneCtldServer) CreateReservation(context.Context, *CreateReservationRequest) (*CreateReservationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReservation not implemented")
}
func (UnimplementedCraneCtldServer) DeleteReservation(context.Context, *DeleteReservationRequest) (*DeleteReservationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReservation not implemented")
}
func (UnimplementedCraneCtldServer) PowerStateChange(context.Context, *PowerStateChangeRequest) (*PowerStateChangeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PowerStateChange not implemented")
}
func (UnimplementedCraneCtldServer) testEmbeddedByValue() {}

// UnsafeCraneCtldServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CraneCtldServer will
// result in compilation errors.
type UnsafeCraneCtldServer interface {
	mustEmbedUnimplementedCraneCtldServer()
}

func RegisterCraneCtldServer(s grpc.ServiceRegistrar, srv CraneCtldServer) {
	// If the following call pancis, it indicates UnimplementedCraneCtldServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CraneCtld_ServiceDesc, srv)
}

func _CraneCtld_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_CancelTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).CancelTask(ctx, req.(*CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_SubmitBatchTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).SubmitBatchTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_SubmitBatchTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).SubmitBatchTask(ctx, req.(*SubmitBatchTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_SubmitBatchTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).SubmitBatchTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_SubmitBatchTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).SubmitBatchTasks(ctx, req.(*SubmitBatchTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryCranedInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCranedInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryCranedInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryCranedInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryCranedInfo(ctx, req.(*QueryCranedInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryPartitionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPartitionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryPartitionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryPartitionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryPartitionInfo(ctx, req.(*QueryPartitionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryReservationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReservationInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryReservationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryReservationInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryReservationInfo(ctx, req.(*QueryReservationInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyTask(ctx, req.(*ModifyTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyCranedStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyNode(ctx, req.(*ModifyCranedStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyPartitionAcl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyPartitionAclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyPartitionAcl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyPartitionAcl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyPartitionAcl(ctx, req.(*ModifyPartitionAclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_EnableAutoPowerControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableAutoPowerControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).EnableAutoPowerControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_EnableAutoPowerControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).EnableAutoPowerControl(ctx, req.(*EnableAutoPowerControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_AddAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).AddAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_AddAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).AddAccount(ctx, req.(*AddAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_AddUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).AddUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_AddUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).AddUser(ctx, req.(*AddUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_AddQos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddQosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).AddQos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_AddQos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).AddQos(ctx, req.(*AddQosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteQos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteQos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteQos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteQos(ctx, req.(*DeleteQosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryAccountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryAccountInfo(ctx, req.(*QueryAccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryUserInfo(ctx, req.(*QueryUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryQosInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryQosInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryQosInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryQosInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryQosInfo(ctx, req.(*QueryQosInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyAccount(ctx, req.(*ModifyAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyUser(ctx, req.(*ModifyUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyQos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyQosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyQos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyQos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyQos(ctx, req.(*ModifyQosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_BlockAccountOrUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockAccountOrUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).BlockAccountOrUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_BlockAccountOrUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).BlockAccountOrUser(ctx, req.(*BlockAccountOrUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryClusterInfo(ctx, req.(*QueryClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryTasksInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTasksInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryTasksInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryTasksInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryTasksInfo(ctx, req.(*QueryTasksInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_CreateReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).CreateReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_CreateReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).CreateReservation(ctx, req.(*CreateReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteReservation(ctx, req.(*DeleteReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_PowerStateChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerStateChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).PowerStateChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_PowerStateChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).PowerStateChange(ctx, req.(*PowerStateChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CraneCtld_ServiceDesc is the grpc.ServiceDesc for CraneCtld service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CraneCtld_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CraneCtld",
	HandlerType: (*CraneCtldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelTask",
			Handler:    _CraneCtld_CancelTask_Handler,
		},
		{
			MethodName: "SubmitBatchTask",
			Handler:    _CraneCtld_SubmitBatchTask_Handler,
		},
		{
			MethodName: "SubmitBatchTasks",
			Handler:    _CraneCtld_SubmitBatchTasks_Handler,
		},
		{
			MethodName: "QueryCranedInfo",
			Handler:    _CraneCtld_QueryCranedInfo_Handler,
		},
		{
			MethodName: "QueryPartitionInfo",
			Handler:    _CraneCtld_QueryPartitionInfo_Handler,
		},
		{
			MethodName: "QueryReservationInfo",
			Handler:    _CraneCtld_QueryReservationInfo_Handler,
		},
		{
			MethodName: "ModifyTask",
			Handler:    _CraneCtld_ModifyTask_Handler,
		},
		{
			MethodName: "ModifyNode",
			Handler:    _CraneCtld_ModifyNode_Handler,
		},
		{
			MethodName: "ModifyPartitionAcl",
			Handler:    _CraneCtld_ModifyPartitionAcl_Handler,
		},
		{
			MethodName: "EnableAutoPowerControl",
			Handler:    _CraneCtld_EnableAutoPowerControl_Handler,
		},
		{
			MethodName: "AddAccount",
			Handler:    _CraneCtld_AddAccount_Handler,
		},
		{
			MethodName: "AddUser",
			Handler:    _CraneCtld_AddUser_Handler,
		},
		{
			MethodName: "AddQos",
			Handler:    _CraneCtld_AddQos_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _CraneCtld_DeleteAccount_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _CraneCtld_DeleteUser_Handler,
		},
		{
			MethodName: "DeleteQos",
			Handler:    _CraneCtld_DeleteQos_Handler,
		},
		{
			MethodName: "QueryAccountInfo",
			Handler:    _CraneCtld_QueryAccountInfo_Handler,
		},
		{
			MethodName: "QueryUserInfo",
			Handler:    _CraneCtld_QueryUserInfo_Handler,
		},
		{
			MethodName: "QueryQosInfo",
			Handler:    _CraneCtld_QueryQosInfo_Handler,
		},
		{
			MethodName: "ModifyAccount",
			Handler:    _CraneCtld_ModifyAccount_Handler,
		},
		{
			MethodName: "ModifyUser",
			Handler:    _CraneCtld_ModifyUser_Handler,
		},
		{
			MethodName: "ModifyQos",
			Handler:    _CraneCtld_ModifyQos_Handler,
		},
		{
			MethodName: "BlockAccountOrUser",
			Handler:    _CraneCtld_BlockAccountOrUser_Handler,
		},
		{
			MethodName: "QueryClusterInfo",
			Handler:    _CraneCtld_QueryClusterInfo_Handler,
		},
		{
			MethodName: "QueryTasksInfo",
			Handler:    _CraneCtld_QueryTasksInfo_Handler,
		},
		{
			MethodName: "CreateReservation",
			Handler:    _CraneCtld_CreateReservation_Handler,
		},
		{
			MethodName: "DeleteReservation",
			Handler:    _CraneCtld_DeleteReservation_Handler,
		},
		{
			MethodName: "PowerStateChange",
			Handler:    _CraneCtld_PowerStateChange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Crane.proto",
}

const (
	CraneCtldForInternal_TaskStatusChange_FullMethodName         = "/crane.grpc.CraneCtldForInternal/TaskStatusChange"
	CraneCtldForInternal_CranedTriggerReverseConn_FullMethodName = "/crane.grpc.CraneCtldForInternal/CranedTriggerReverseConn"
	CraneCtldForInternal_CranedRegister_FullMethodName           = "/crane.grpc.CraneCtldForInternal/CranedRegister"
	CraneCtldForInternal_CforedStream_FullMethodName             = "/crane.grpc.CraneCtldForInternal/CforedStream"
)

// CraneCtldForInternalClient is the client API for CraneCtldForInternal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CraneCtldForInternalClient interface {
	// RPCs called from Craned
	TaskStatusChange(ctx context.Context, in *TaskStatusChangeRequest, opts ...grpc.CallOption) (*TaskStatusChangeReply, error)
	CranedTriggerReverseConn(ctx context.Context, in *CranedTriggerReverseConnRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CranedRegister(ctx context.Context, in *CranedRegisterRequest, opts ...grpc.CallOption) (*CranedRegisterReply, error)
	// RPCs called from Cfored
	CforedStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCforedRequest, StreamCtldReply], error)
}

type craneCtldForInternalClient struct {
	cc grpc.ClientConnInterface
}

func NewCraneCtldForInternalClient(cc grpc.ClientConnInterface) CraneCtldForInternalClient {
	return &craneCtldForInternalClient{cc}
}

func (c *craneCtldForInternalClient) TaskStatusChange(ctx context.Context, in *TaskStatusChangeRequest, opts ...grpc.CallOption) (*TaskStatusChangeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskStatusChangeReply)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_TaskStatusChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CranedTriggerReverseConn(ctx context.Context, in *CranedTriggerReverseConnRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_CranedTriggerReverseConn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CranedRegister(ctx context.Context, in *CranedRegisterRequest, opts ...grpc.CallOption) (*CranedRegisterReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CranedRegisterReply)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_CranedRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CforedStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCforedRequest, StreamCtldReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneCtldForInternal_ServiceDesc.Streams[0], CraneCtldForInternal_CforedStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCforedRequest, StreamCtldReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneCtldForInternal_CforedStreamClient = grpc.BidiStreamingClient[StreamCforedRequest, StreamCtldReply]

// CraneCtldForInternalServer is the server API for CraneCtldForInternal service.
// All implementations should embed UnimplementedCraneCtldForInternalServer
// for forward compatibility.
type CraneCtldForInternalServer interface {
	// RPCs called from Craned
	TaskStatusChange(context.Context, *TaskStatusChangeRequest) (*TaskStatusChangeReply, error)
	CranedTriggerReverseConn(context.Context, *CranedTriggerReverseConnRequest) (*emptypb.Empty, error)
	CranedRegister(context.Context, *CranedRegisterRequest) (*CranedRegisterReply, error)
	// RPCs called from Cfored
	CforedStream(grpc.BidiStreamingServer[StreamCforedRequest, StreamCtldReply]) error
}

// UnimplementedCraneCtldForInternalServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCraneCtldForInternalServer struct{}

func (UnimplementedCraneCtldForInternalServer) TaskStatusChange(context.Context, *TaskStatusChangeRequest) (*TaskStatusChangeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskStatusChange not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CranedTriggerReverseConn(context.Context, *CranedTriggerReverseConnRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CranedTriggerReverseConn not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CranedRegister(context.Context, *CranedRegisterRequest) (*CranedRegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CranedRegister not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CforedStream(grpc.BidiStreamingServer[StreamCforedRequest, StreamCtldReply]) error {
	return status.Errorf(codes.Unimplemented, "method CforedStream not implemented")
}
func (UnimplementedCraneCtldForInternalServer) testEmbeddedByValue() {}

// UnsafeCraneCtldForInternalServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CraneCtldForInternalServer will
// result in compilation errors.
type UnsafeCraneCtldForInternalServer interface {
	mustEmbedUnimplementedCraneCtldForInternalServer()
}

func RegisterCraneCtldForInternalServer(s grpc.ServiceRegistrar, srv CraneCtldForInternalServer) {
	// If the following call pancis, it indicates UnimplementedCraneCtldForInternalServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CraneCtldForInternal_ServiceDesc, srv)
}

func _CraneCtldForInternal_TaskStatusChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskStatusChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).TaskStatusChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_TaskStatusChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).TaskStatusChange(ctx, req.(*TaskStatusChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CranedTriggerReverseConn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CranedTriggerReverseConnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).CranedTriggerReverseConn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_CranedTriggerReverseConn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).CranedTriggerReverseConn(ctx, req.(*CranedTriggerReverseConnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CranedRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CranedRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).CranedRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_CranedRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).CranedRegister(ctx, req.(*CranedRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CforedStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneCtldForInternalServer).CforedStream(&grpc.GenericServerStream[StreamCforedRequest, StreamCtldReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneCtldForInternal_CforedStreamServer = grpc.BidiStreamingServer[StreamCforedRequest, StreamCtldReply]

// CraneCtldForInternal_ServiceDesc is the grpc.ServiceDesc for CraneCtldForInternal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CraneCtldForInternal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CraneCtldForInternal",
	HandlerType: (*CraneCtldForInternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TaskStatusChange",
			Handler:    _CraneCtldForInternal_TaskStatusChange_Handler,
		},
		{
			MethodName: "CranedTriggerReverseConn",
			Handler:    _CraneCtldForInternal_CranedTriggerReverseConn_Handler,
		},
		{
			MethodName: "CranedRegister",
			Handler:    _CraneCtldForInternal_CranedRegister_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CforedStream",
			Handler:       _CraneCtldForInternal_CforedStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "Crane.proto",
}

const (
	Craned_Configure_FullMethodName             = "/crane.grpc.Craned/Configure"
	Craned_ExecuteTask_FullMethodName           = "/crane.grpc.Craned/ExecuteTask"
	Craned_CreateCgroupForTasks_FullMethodName  = "/crane.grpc.Craned/CreateCgroupForTasks"
	Craned_ReleaseCgroupForTasks_FullMethodName = "/crane.grpc.Craned/ReleaseCgroupForTasks"
	Craned_TerminateTasks_FullMethodName        = "/crane.grpc.Craned/TerminateTasks"
	Craned_TerminateOrphanedTask_FullMethodName = "/crane.grpc.Craned/TerminateOrphanedTask"
	Craned_ChangeTaskTimeLimit_FullMethodName   = "/crane.grpc.Craned/ChangeTaskTimeLimit"
	Craned_QueryTaskIdFromPort_FullMethodName   = "/crane.grpc.Craned/QueryTaskIdFromPort"
	Craned_QueryTaskEnvVariables_FullMethodName = "/crane.grpc.Craned/QueryTaskEnvVariables"
)

// CranedClient is the client API for Craned service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CranedClient interface {
	// ----------------------------------- Called from CraneCtld ----------------------------------------------------
	Configure(ctx context.Context, in *ConfigureCranedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ExecuteTask(ctx context.Context, in *ExecuteTasksRequest, opts ...grpc.CallOption) (*ExecuteTasksReply, error)
	CreateCgroupForTasks(ctx context.Context, in *CreateCgroupForTasksRequest, opts ...grpc.CallOption) (*CreateCgroupForTasksReply, error)
	ReleaseCgroupForTasks(ctx context.Context, in *ReleaseCgroupForTasksRequest, opts ...grpc.CallOption) (*ReleaseCgroupForTasksReply, error)
	// If the task is an interactive task, the resource uuid is also revoked.
	// If there's no process in this interactive task, just deallocate all the resources.
	// If there are processes in this interactive task, kill all the processes and deallocate resources.
	// If the task is a batch task, just kill it.
	TerminateTasks(ctx context.Context, in *TerminateTasksRequest, opts ...grpc.CallOption) (*TerminateTasksReply, error)
	TerminateOrphanedTask(ctx context.Context, in *TerminateOrphanedTaskRequest, opts ...grpc.CallOption) (*TerminateOrphanedTaskReply, error)
	ChangeTaskTimeLimit(ctx context.Context, in *ChangeTaskTimeLimitRequest, opts ...grpc.CallOption) (*ChangeTaskTimeLimitReply, error)
	// ----------------------------------- Called from Craned  ------------------------------------------------------
	QueryTaskIdFromPort(ctx context.Context, in *QueryTaskIdFromPortRequest, opts ...grpc.CallOption) (*QueryTaskIdFromPortReply, error)
	QueryTaskEnvVariables(ctx context.Context, in *QueryTaskEnvVariablesRequest, opts ...grpc.CallOption) (*QueryTaskEnvVariablesReply, error)
}

type cranedClient struct {
	cc grpc.ClientConnInterface
}

func NewCranedClient(cc grpc.ClientConnInterface) CranedClient {
	return &cranedClient{cc}
}

func (c *cranedClient) Configure(ctx context.Context, in *ConfigureCranedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Craned_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) ExecuteTask(ctx context.Context, in *ExecuteTasksRequest, opts ...grpc.CallOption) (*ExecuteTasksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteTasksReply)
	err := c.cc.Invoke(ctx, Craned_ExecuteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) CreateCgroupForTasks(ctx context.Context, in *CreateCgroupForTasksRequest, opts ...grpc.CallOption) (*CreateCgroupForTasksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCgroupForTasksReply)
	err := c.cc.Invoke(ctx, Craned_CreateCgroupForTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) ReleaseCgroupForTasks(ctx context.Context, in *ReleaseCgroupForTasksRequest, opts ...grpc.CallOption) (*ReleaseCgroupForTasksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseCgroupForTasksReply)
	err := c.cc.Invoke(ctx, Craned_ReleaseCgroupForTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) TerminateTasks(ctx context.Context, in *TerminateTasksRequest, opts ...grpc.CallOption) (*TerminateTasksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateTasksReply)
	err := c.cc.Invoke(ctx, Craned_TerminateTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) TerminateOrphanedTask(ctx context.Context, in *TerminateOrphanedTaskRequest, opts ...grpc.CallOption) (*TerminateOrphanedTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateOrphanedTaskReply)
	err := c.cc.Invoke(ctx, Craned_TerminateOrphanedTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) ChangeTaskTimeLimit(ctx context.Context, in *ChangeTaskTimeLimitRequest, opts ...grpc.CallOption) (*ChangeTaskTimeLimitReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeTaskTimeLimitReply)
	err := c.cc.Invoke(ctx, Craned_ChangeTaskTimeLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) QueryTaskIdFromPort(ctx context.Context, in *QueryTaskIdFromPortRequest, opts ...grpc.CallOption) (*QueryTaskIdFromPortReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTaskIdFromPortReply)
	err := c.cc.Invoke(ctx, Craned_QueryTaskIdFromPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) QueryTaskEnvVariables(ctx context.Context, in *QueryTaskEnvVariablesRequest, opts ...grpc.CallOption) (*QueryTaskEnvVariablesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTaskEnvVariablesReply)
	err := c.cc.Invoke(ctx, Craned_QueryTaskEnvVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CranedServer is the server API for Craned service.
// All implementations should embed UnimplementedCranedServer
// for forward compatibility.
type CranedServer interface {
	// ----------------------------------- Called from CraneCtld ----------------------------------------------------
	Configure(context.Context, *ConfigureCranedRequest) (*emptypb.Empty, error)
	ExecuteTask(context.Context, *ExecuteTasksRequest) (*ExecuteTasksReply, error)
	CreateCgroupForTasks(context.Context, *CreateCgroupForTasksRequest) (*CreateCgroupForTasksReply, error)
	ReleaseCgroupForTasks(context.Context, *ReleaseCgroupForTasksRequest) (*ReleaseCgroupForTasksReply, error)
	// If the task is an interactive task, the resource uuid is also revoked.
	// If there's no process in this interactive task, just deallocate all the resources.
	// If there are processes in this interactive task, kill all the processes and deallocate resources.
	// If the task is a batch task, just kill it.
	TerminateTasks(context.Context, *TerminateTasksRequest) (*TerminateTasksReply, error)
	TerminateOrphanedTask(context.Context, *TerminateOrphanedTaskRequest) (*TerminateOrphanedTaskReply, error)
	ChangeTaskTimeLimit(context.Context, *ChangeTaskTimeLimitRequest) (*ChangeTaskTimeLimitReply, error)
	// ----------------------------------- Called from Craned  ------------------------------------------------------
	QueryTaskIdFromPort(context.Context, *QueryTaskIdFromPortRequest) (*QueryTaskIdFromPortReply, error)
	QueryTaskEnvVariables(context.Context, *QueryTaskEnvVariablesRequest) (*QueryTaskEnvVariablesReply, error)
}

// UnimplementedCranedServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCranedServer struct{}

func (UnimplementedCranedServer) Configure(context.Context, *ConfigureCranedRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCranedServer) ExecuteTask(context.Context, *ExecuteTasksRequest) (*ExecuteTasksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTask not implemented")
}
func (UnimplementedCranedServer) CreateCgroupForTasks(context.Context, *CreateCgroupForTasksRequest) (*CreateCgroupForTasksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCgroupForTasks not implemented")
}
func (UnimplementedCranedServer) ReleaseCgroupForTasks(context.Context, *ReleaseCgroupForTasksRequest) (*ReleaseCgroupForTasksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseCgroupForTasks not implemented")
}
func (UnimplementedCranedServer) TerminateTasks(context.Context, *TerminateTasksRequest) (*TerminateTasksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateTasks not implemented")
}
func (UnimplementedCranedServer) TerminateOrphanedTask(context.Context, *TerminateOrphanedTaskRequest) (*TerminateOrphanedTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateOrphanedTask not implemented")
}
func (UnimplementedCranedServer) ChangeTaskTimeLimit(context.Context, *ChangeTaskTimeLimitRequest) (*ChangeTaskTimeLimitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeTaskTimeLimit not implemented")
}
func (UnimplementedCranedServer) QueryTaskIdFromPort(context.Context, *QueryTaskIdFromPortRequest) (*QueryTaskIdFromPortReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTaskIdFromPort not implemented")
}
func (UnimplementedCranedServer) QueryTaskEnvVariables(context.Context, *QueryTaskEnvVariablesRequest) (*QueryTaskEnvVariablesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTaskEnvVariables not implemented")
}
func (UnimplementedCranedServer) testEmbeddedByValue() {}

// UnsafeCranedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CranedServer will
// result in compilation errors.
type UnsafeCranedServer interface {
	mustEmbedUnimplementedCranedServer()
}

func RegisterCranedServer(s grpc.ServiceRegistrar, srv CranedServer) {
	// If the following call pancis, it indicates UnimplementedCranedServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Craned_ServiceDesc, srv)
}

func _Craned_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureCranedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).Configure(ctx, req.(*ConfigureCranedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_ExecuteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).ExecuteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_ExecuteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).ExecuteTask(ctx, req.(*ExecuteTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_CreateCgroupForTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCgroupForTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).CreateCgroupForTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_CreateCgroupForTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).CreateCgroupForTasks(ctx, req.(*CreateCgroupForTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_ReleaseCgroupForTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseCgroupForTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).ReleaseCgroupForTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_ReleaseCgroupForTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).ReleaseCgroupForTasks(ctx, req.(*ReleaseCgroupForTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_TerminateTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).TerminateTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_TerminateTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).TerminateTasks(ctx, req.(*TerminateTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_TerminateOrphanedTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateOrphanedTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).TerminateOrphanedTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_TerminateOrphanedTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).TerminateOrphanedTask(ctx, req.(*TerminateOrphanedTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_ChangeTaskTimeLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeTaskTimeLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).ChangeTaskTimeLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_ChangeTaskTimeLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).ChangeTaskTimeLimit(ctx, req.(*ChangeTaskTimeLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_QueryTaskIdFromPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskIdFromPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).QueryTaskIdFromPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_QueryTaskIdFromPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).QueryTaskIdFromPort(ctx, req.(*QueryTaskIdFromPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_QueryTaskEnvVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskEnvVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).QueryTaskEnvVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_QueryTaskEnvVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).QueryTaskEnvVariables(ctx, req.(*QueryTaskEnvVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Craned_ServiceDesc is the grpc.ServiceDesc for Craned service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Craned_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.Craned",
	HandlerType: (*CranedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Configure",
			Handler:    _Craned_Configure_Handler,
		},
		{
			MethodName: "ExecuteTask",
			Handler:    _Craned_ExecuteTask_Handler,
		},
		{
			MethodName: "CreateCgroupForTasks",
			Handler:    _Craned_CreateCgroupForTasks_Handler,
		},
		{
			MethodName: "ReleaseCgroupForTasks",
			Handler:    _Craned_ReleaseCgroupForTasks_Handler,
		},
		{
			MethodName: "TerminateTasks",
			Handler:    _Craned_TerminateTasks_Handler,
		},
		{
			MethodName: "TerminateOrphanedTask",
			Handler:    _Craned_TerminateOrphanedTask_Handler,
		},
		{
			MethodName: "ChangeTaskTimeLimit",
			Handler:    _Craned_ChangeTaskTimeLimit_Handler,
		},
		{
			MethodName: "QueryTaskIdFromPort",
			Handler:    _Craned_QueryTaskIdFromPort_Handler,
		},
		{
			MethodName: "QueryTaskEnvVariables",
			Handler:    _Craned_QueryTaskEnvVariables_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Crane.proto",
}

const (
	CranedForPam_QueryTaskIdFromPortForward_FullMethodName   = "/crane.grpc.CranedForPam/QueryTaskIdFromPortForward"
	CranedForPam_MigrateSshProcToCgroup_FullMethodName       = "/crane.grpc.CranedForPam/MigrateSshProcToCgroup"
	CranedForPam_QueryTaskEnvVariablesForward_FullMethodName = "/crane.grpc.CranedForPam/QueryTaskEnvVariablesForward"
)

// CranedForPamClient is the client API for CranedForPam service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CranedForPamClient interface {
	// ----------------------------------- Called from Pam Module  ---------------------------------------------------
	QueryTaskIdFromPortForward(ctx context.Context, in *QueryTaskIdFromPortForwardRequest, opts ...grpc.CallOption) (*QueryTaskIdFromPortForwardReply, error)
	MigrateSshProcToCgroup(ctx context.Context, in *MigrateSshProcToCgroupRequest, opts ...grpc.CallOption) (*MigrateSshProcToCgroupReply, error)
	QueryTaskEnvVariablesForward(ctx context.Context, in *QueryTaskEnvVariablesForwardRequest, opts ...grpc.CallOption) (*QueryTaskEnvVariablesForwardReply, error)
}

type cranedForPamClient struct {
	cc grpc.ClientConnInterface
}

func NewCranedForPamClient(cc grpc.ClientConnInterface) CranedForPamClient {
	return &cranedForPamClient{cc}
}

func (c *cranedForPamClient) QueryTaskIdFromPortForward(ctx context.Context, in *QueryTaskIdFromPortForwardRequest, opts ...grpc.CallOption) (*QueryTaskIdFromPortForwardReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTaskIdFromPortForwardReply)
	err := c.cc.Invoke(ctx, CranedForPam_QueryTaskIdFromPortForward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedForPamClient) MigrateSshProcToCgroup(ctx context.Context, in *MigrateSshProcToCgroupRequest, opts ...grpc.CallOption) (*MigrateSshProcToCgroupReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateSshProcToCgroupReply)
	err := c.cc.Invoke(ctx, CranedForPam_MigrateSshProcToCgroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedForPamClient) QueryTaskEnvVariablesForward(ctx context.Context, in *QueryTaskEnvVariablesForwardRequest, opts ...grpc.CallOption) (*QueryTaskEnvVariablesForwardReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTaskEnvVariablesForwardReply)
	err := c.cc.Invoke(ctx, CranedForPam_QueryTaskEnvVariablesForward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CranedForPamServer is the server API for CranedForPam service.
// All implementations should embed UnimplementedCranedForPamServer
// for forward compatibility.
type CranedForPamServer interface {
	// ----------------------------------- Called from Pam Module  ---------------------------------------------------
	QueryTaskIdFromPortForward(context.Context, *QueryTaskIdFromPortForwardRequest) (*QueryTaskIdFromPortForwardReply, error)
	MigrateSshProcToCgroup(context.Context, *MigrateSshProcToCgroupRequest) (*MigrateSshProcToCgroupReply, error)
	QueryTaskEnvVariablesForward(context.Context, *QueryTaskEnvVariablesForwardRequest) (*QueryTaskEnvVariablesForwardReply, error)
}

// UnimplementedCranedForPamServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCranedForPamServer struct{}

func (UnimplementedCranedForPamServer) QueryTaskIdFromPortForward(context.Context, *QueryTaskIdFromPortForwardRequest) (*QueryTaskIdFromPortForwardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTaskIdFromPortForward not implemented")
}
func (UnimplementedCranedForPamServer) MigrateSshProcToCgroup(context.Context, *MigrateSshProcToCgroupRequest) (*MigrateSshProcToCgroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateSshProcToCgroup not implemented")
}
func (UnimplementedCranedForPamServer) QueryTaskEnvVariablesForward(context.Context, *QueryTaskEnvVariablesForwardRequest) (*QueryTaskEnvVariablesForwardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTaskEnvVariablesForward not implemented")
}
func (UnimplementedCranedForPamServer) testEmbeddedByValue() {}

// UnsafeCranedForPamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CranedForPamServer will
// result in compilation errors.
type UnsafeCranedForPamServer interface {
	mustEmbedUnimplementedCranedForPamServer()
}

func RegisterCranedForPamServer(s grpc.ServiceRegistrar, srv CranedForPamServer) {
	// If the following call pancis, it indicates UnimplementedCranedForPamServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CranedForPam_ServiceDesc, srv)
}

func _CranedForPam_QueryTaskIdFromPortForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskIdFromPortForwardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedForPamServer).QueryTaskIdFromPortForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CranedForPam_QueryTaskIdFromPortForward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedForPamServer).QueryTaskIdFromPortForward(ctx, req.(*QueryTaskIdFromPortForwardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CranedForPam_MigrateSshProcToCgroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateSshProcToCgroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedForPamServer).MigrateSshProcToCgroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CranedForPam_MigrateSshProcToCgroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedForPamServer).MigrateSshProcToCgroup(ctx, req.(*MigrateSshProcToCgroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CranedForPam_QueryTaskEnvVariablesForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskEnvVariablesForwardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedForPamServer).QueryTaskEnvVariablesForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CranedForPam_QueryTaskEnvVariablesForward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedForPamServer).QueryTaskEnvVariablesForward(ctx, req.(*QueryTaskEnvVariablesForwardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CranedForPam_ServiceDesc is the grpc.ServiceDesc for CranedForPam service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CranedForPam_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CranedForPam",
	HandlerType: (*CranedForPamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryTaskIdFromPortForward",
			Handler:    _CranedForPam_QueryTaskIdFromPortForward_Handler,
		},
		{
			MethodName: "MigrateSshProcToCgroup",
			Handler:    _CranedForPam_MigrateSshProcToCgroup_Handler,
		},
		{
			MethodName: "QueryTaskEnvVariablesForward",
			Handler:    _CranedForPam_QueryTaskEnvVariablesForward_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Crane.proto",
}

const (
	CraneForeD_CallocStream_FullMethodName        = "/crane.grpc.CraneForeD/CallocStream"
	CraneForeD_CrunStream_FullMethodName          = "/crane.grpc.CraneForeD/CrunStream"
	CraneForeD_TaskIOStream_FullMethodName        = "/crane.grpc.CraneForeD/TaskIOStream"
	CraneForeD_QueryTaskIdFromPort_FullMethodName = "/crane.grpc.CraneForeD/QueryTaskIdFromPort"
)

// CraneForeDClient is the client API for CraneForeD service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CraneForeDClient interface {
	CallocStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCallocRequest, StreamCallocReply], error)
	CrunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCrunRequest, StreamCrunReply], error)
	TaskIOStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamTaskIORequest, StreamTaskIOReply], error)
	QueryTaskIdFromPort(ctx context.Context, in *QueryTaskIdFromPortRequest, opts ...grpc.CallOption) (*QueryTaskIdFromPortReply, error)
}

type craneForeDClient struct {
	cc grpc.ClientConnInterface
}

func NewCraneForeDClient(cc grpc.ClientConnInterface) CraneForeDClient {
	return &craneForeDClient{cc}
}

func (c *craneForeDClient) CallocStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCallocRequest, StreamCallocReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneForeD_ServiceDesc.Streams[0], CraneForeD_CallocStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCallocRequest, StreamCallocReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CallocStreamClient = grpc.BidiStreamingClient[StreamCallocRequest, StreamCallocReply]

func (c *craneForeDClient) CrunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCrunRequest, StreamCrunReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneForeD_ServiceDesc.Streams[1], CraneForeD_CrunStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCrunRequest, StreamCrunReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CrunStreamClient = grpc.BidiStreamingClient[StreamCrunRequest, StreamCrunReply]

func (c *craneForeDClient) TaskIOStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamTaskIORequest, StreamTaskIOReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneForeD_ServiceDesc.Streams[2], CraneForeD_TaskIOStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamTaskIORequest, StreamTaskIOReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_TaskIOStreamClient = grpc.BidiStreamingClient[StreamTaskIORequest, StreamTaskIOReply]

func (c *craneForeDClient) QueryTaskIdFromPort(ctx context.Context, in *QueryTaskIdFromPortRequest, opts ...grpc.CallOption) (*QueryTaskIdFromPortReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTaskIdFromPortReply)
	err := c.cc.Invoke(ctx, CraneForeD_QueryTaskIdFromPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CraneForeDServer is the server API for CraneForeD service.
// All implementations should embed UnimplementedCraneForeDServer
// for forward compatibility.
type CraneForeDServer interface {
	CallocStream(grpc.BidiStreamingServer[StreamCallocRequest, StreamCallocReply]) error
	CrunStream(grpc.BidiStreamingServer[StreamCrunRequest, StreamCrunReply]) error
	TaskIOStream(grpc.BidiStreamingServer[StreamTaskIORequest, StreamTaskIOReply]) error
	QueryTaskIdFromPort(context.Context, *QueryTaskIdFromPortRequest) (*QueryTaskIdFromPortReply, error)
}

// UnimplementedCraneForeDServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCraneForeDServer struct{}

func (UnimplementedCraneForeDServer) CallocStream(grpc.BidiStreamingServer[StreamCallocRequest, StreamCallocReply]) error {
	return status.Errorf(codes.Unimplemented, "method CallocStream not implemented")
}
func (UnimplementedCraneForeDServer) CrunStream(grpc.BidiStreamingServer[StreamCrunRequest, StreamCrunReply]) error {
	return status.Errorf(codes.Unimplemented, "method CrunStream not implemented")
}
func (UnimplementedCraneForeDServer) TaskIOStream(grpc.BidiStreamingServer[StreamTaskIORequest, StreamTaskIOReply]) error {
	return status.Errorf(codes.Unimplemented, "method TaskIOStream not implemented")
}
func (UnimplementedCraneForeDServer) QueryTaskIdFromPort(context.Context, *QueryTaskIdFromPortRequest) (*QueryTaskIdFromPortReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTaskIdFromPort not implemented")
}
func (UnimplementedCraneForeDServer) testEmbeddedByValue() {}

// UnsafeCraneForeDServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CraneForeDServer will
// result in compilation errors.
type UnsafeCraneForeDServer interface {
	mustEmbedUnimplementedCraneForeDServer()
}

func RegisterCraneForeDServer(s grpc.ServiceRegistrar, srv CraneForeDServer) {
	// If the following call pancis, it indicates UnimplementedCraneForeDServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CraneForeD_ServiceDesc, srv)
}

func _CraneForeD_CallocStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneForeDServer).CallocStream(&grpc.GenericServerStream[StreamCallocRequest, StreamCallocReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CallocStreamServer = grpc.BidiStreamingServer[StreamCallocRequest, StreamCallocReply]

func _CraneForeD_CrunStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneForeDServer).CrunStream(&grpc.GenericServerStream[StreamCrunRequest, StreamCrunReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CrunStreamServer = grpc.BidiStreamingServer[StreamCrunRequest, StreamCrunReply]

func _CraneForeD_TaskIOStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneForeDServer).TaskIOStream(&grpc.GenericServerStream[StreamTaskIORequest, StreamTaskIOReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_TaskIOStreamServer = grpc.BidiStreamingServer[StreamTaskIORequest, StreamTaskIOReply]

func _CraneForeD_QueryTaskIdFromPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTaskIdFromPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneForeDServer).QueryTaskIdFromPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneForeD_QueryTaskIdFromPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneForeDServer).QueryTaskIdFromPort(ctx, req.(*QueryTaskIdFromPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CraneForeD_ServiceDesc is the grpc.ServiceDesc for CraneForeD service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CraneForeD_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CraneForeD",
	HandlerType: (*CraneForeDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryTaskIdFromPort",
			Handler:    _CraneForeD_QueryTaskIdFromPort_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CallocStream",
			Handler:       _CraneForeD_CallocStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CrunStream",
			Handler:       _CraneForeD_CrunStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TaskIOStream",
			Handler:       _CraneForeD_TaskIOStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "Crane.proto",
}
