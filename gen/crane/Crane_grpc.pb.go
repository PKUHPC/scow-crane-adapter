//*
// Copyright (c) 2024 Peking University and Peking University
// Changsha Institute for Computing and Digital Economy
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: Crane.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CraneCtld_CancelTask_FullMethodName             = "/crane.grpc.CraneCtld/CancelTask"
	CraneCtld_SubmitBatchTask_FullMethodName        = "/crane.grpc.CraneCtld/SubmitBatchTask"
	CraneCtld_SubmitBatchTasks_FullMethodName       = "/crane.grpc.CraneCtld/SubmitBatchTasks"
	CraneCtld_QueryCranedInfo_FullMethodName        = "/crane.grpc.CraneCtld/QueryCranedInfo"
	CraneCtld_QueryPartitionInfo_FullMethodName     = "/crane.grpc.CraneCtld/QueryPartitionInfo"
	CraneCtld_QueryReservationInfo_FullMethodName   = "/crane.grpc.CraneCtld/QueryReservationInfo"
	CraneCtld_ModifyTask_FullMethodName             = "/crane.grpc.CraneCtld/ModifyTask"
	CraneCtld_ModifyNode_FullMethodName             = "/crane.grpc.CraneCtld/ModifyNode"
	CraneCtld_ModifyPartitionAcl_FullMethodName     = "/crane.grpc.CraneCtld/ModifyPartitionAcl"
	CraneCtld_EnableAutoPowerControl_FullMethodName = "/crane.grpc.CraneCtld/EnableAutoPowerControl"
	CraneCtld_ModifyTasksExtraAttrs_FullMethodName  = "/crane.grpc.CraneCtld/ModifyTasksExtraAttrs"
	CraneCtld_AddAccount_FullMethodName             = "/crane.grpc.CraneCtld/AddAccount"
	CraneCtld_AddUser_FullMethodName                = "/crane.grpc.CraneCtld/AddUser"
	CraneCtld_AddQos_FullMethodName                 = "/crane.grpc.CraneCtld/AddQos"
	CraneCtld_DeleteAccount_FullMethodName          = "/crane.grpc.CraneCtld/DeleteAccount"
	CraneCtld_DeleteUser_FullMethodName             = "/crane.grpc.CraneCtld/DeleteUser"
	CraneCtld_DeleteQos_FullMethodName              = "/crane.grpc.CraneCtld/DeleteQos"
	CraneCtld_QueryAccountInfo_FullMethodName       = "/crane.grpc.CraneCtld/QueryAccountInfo"
	CraneCtld_QueryUserInfo_FullMethodName          = "/crane.grpc.CraneCtld/QueryUserInfo"
	CraneCtld_QueryQosInfo_FullMethodName           = "/crane.grpc.CraneCtld/QueryQosInfo"
	CraneCtld_ModifyAccount_FullMethodName          = "/crane.grpc.CraneCtld/ModifyAccount"
	CraneCtld_ModifyUser_FullMethodName             = "/crane.grpc.CraneCtld/ModifyUser"
	CraneCtld_ModifyQos_FullMethodName              = "/crane.grpc.CraneCtld/ModifyQos"
	CraneCtld_BlockAccountOrUser_FullMethodName     = "/crane.grpc.CraneCtld/BlockAccountOrUser"
	CraneCtld_ResetUserCredential_FullMethodName    = "/crane.grpc.CraneCtld/ResetUserCredential"
	CraneCtld_QueryTxnLog_FullMethodName            = "/crane.grpc.CraneCtld/QueryTxnLog"
	CraneCtld_QueryClusterInfo_FullMethodName       = "/crane.grpc.CraneCtld/QueryClusterInfo"
	CraneCtld_QueryTasksInfo_FullMethodName         = "/crane.grpc.CraneCtld/QueryTasksInfo"
	CraneCtld_CreateReservation_FullMethodName      = "/crane.grpc.CraneCtld/CreateReservation"
	CraneCtld_DeleteReservation_FullMethodName      = "/crane.grpc.CraneCtld/DeleteReservation"
	CraneCtld_PowerStateChange_FullMethodName       = "/crane.grpc.CraneCtld/PowerStateChange"
	CraneCtld_SignUserCertificate_FullMethodName    = "/crane.grpc.CraneCtld/SignUserCertificate"
)

// CraneCtldClient is the client API for CraneCtld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Todo: Divide service into two parts: one for Craned and one for Crun
//
//	We need to distinguish the message sender
//	and have some kind of authentication
type CraneCtldClient interface {
	// RPCs called from ccancel
	CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskReply, error)
	// RPCs called from cbatch
	SubmitBatchTask(ctx context.Context, in *SubmitBatchTaskRequest, opts ...grpc.CallOption) (*SubmitBatchTaskReply, error)
	SubmitBatchTasks(ctx context.Context, in *SubmitBatchTasksRequest, opts ...grpc.CallOption) (*SubmitBatchTasksReply, error)
	// PRCs called from ccontrol
	QueryCranedInfo(ctx context.Context, in *QueryCranedInfoRequest, opts ...grpc.CallOption) (*QueryCranedInfoReply, error)
	QueryPartitionInfo(ctx context.Context, in *QueryPartitionInfoRequest, opts ...grpc.CallOption) (*QueryPartitionInfoReply, error)
	QueryReservationInfo(ctx context.Context, in *QueryReservationInfoRequest, opts ...grpc.CallOption) (*QueryReservationInfoReply, error)
	ModifyTask(ctx context.Context, in *ModifyTaskRequest, opts ...grpc.CallOption) (*ModifyTaskReply, error)
	ModifyNode(ctx context.Context, in *ModifyCranedStateRequest, opts ...grpc.CallOption) (*ModifyCranedStateReply, error)
	ModifyPartitionAcl(ctx context.Context, in *ModifyPartitionAclRequest, opts ...grpc.CallOption) (*ModifyPartitionAclReply, error)
	EnableAutoPowerControl(ctx context.Context, in *EnableAutoPowerControlRequest, opts ...grpc.CallOption) (*EnableAutoPowerControlReply, error)
	ModifyTasksExtraAttrs(ctx context.Context, in *ModifyTasksExtraAttrsRequest, opts ...grpc.CallOption) (*ModifyTasksExtraAttrsReply, error)
	// RPCs called from cacctmgr
	AddAccount(ctx context.Context, in *AddAccountRequest, opts ...grpc.CallOption) (*AddAccountReply, error)
	AddUser(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserReply, error)
	AddQos(ctx context.Context, in *AddQosRequest, opts ...grpc.CallOption) (*AddQosReply, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountReply, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserReply, error)
	DeleteQos(ctx context.Context, in *DeleteQosRequest, opts ...grpc.CallOption) (*DeleteQosReply, error)
	QueryAccountInfo(ctx context.Context, in *QueryAccountInfoRequest, opts ...grpc.CallOption) (*QueryAccountInfoReply, error)
	QueryUserInfo(ctx context.Context, in *QueryUserInfoRequest, opts ...grpc.CallOption) (*QueryUserInfoReply, error)
	QueryQosInfo(ctx context.Context, in *QueryQosInfoRequest, opts ...grpc.CallOption) (*QueryQosInfoReply, error)
	ModifyAccount(ctx context.Context, in *ModifyAccountRequest, opts ...grpc.CallOption) (*ModifyAccountReply, error)
	ModifyUser(ctx context.Context, in *ModifyUserRequest, opts ...grpc.CallOption) (*ModifyUserReply, error)
	ModifyQos(ctx context.Context, in *ModifyQosRequest, opts ...grpc.CallOption) (*ModifyQosReply, error)
	BlockAccountOrUser(ctx context.Context, in *BlockAccountOrUserRequest, opts ...grpc.CallOption) (*BlockAccountOrUserReply, error)
	ResetUserCredential(ctx context.Context, in *ResetUserCredentialRequest, opts ...grpc.CallOption) (*ResetUserCredentialReply, error)
	QueryTxnLog(ctx context.Context, in *QueryTxnLogRequest, opts ...grpc.CallOption) (*QueryTxnLogReply, error)
	// RPCs called from cinfo
	QueryClusterInfo(ctx context.Context, in *QueryClusterInfoRequest, opts ...grpc.CallOption) (*QueryClusterInfoReply, error)
	// common RPCs
	QueryTasksInfo(ctx context.Context, in *QueryTasksInfoRequest, opts ...grpc.CallOption) (*QueryTasksInfoReply, error)
	CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*CreateReservationReply, error)
	DeleteReservation(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*DeleteReservationReply, error)
	// RPC called form plugin
	PowerStateChange(ctx context.Context, in *PowerStateChangeRequest, opts ...grpc.CallOption) (*PowerStateChangeReply, error)
	// RPCS called from PKI request
	SignUserCertificate(ctx context.Context, in *SignUserCertificateRequest, opts ...grpc.CallOption) (*SignUserCertificateResponse, error)
}

type craneCtldClient struct {
	cc grpc.ClientConnInterface
}

func NewCraneCtldClient(cc grpc.ClientConnInterface) CraneCtldClient {
	return &craneCtldClient{cc}
}

func (c *craneCtldClient) CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelTaskReply)
	err := c.cc.Invoke(ctx, CraneCtld_CancelTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) SubmitBatchTask(ctx context.Context, in *SubmitBatchTaskRequest, opts ...grpc.CallOption) (*SubmitBatchTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBatchTaskReply)
	err := c.cc.Invoke(ctx, CraneCtld_SubmitBatchTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) SubmitBatchTasks(ctx context.Context, in *SubmitBatchTasksRequest, opts ...grpc.CallOption) (*SubmitBatchTasksReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitBatchTasksReply)
	err := c.cc.Invoke(ctx, CraneCtld_SubmitBatchTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryCranedInfo(ctx context.Context, in *QueryCranedInfoRequest, opts ...grpc.CallOption) (*QueryCranedInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryCranedInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryCranedInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryPartitionInfo(ctx context.Context, in *QueryPartitionInfoRequest, opts ...grpc.CallOption) (*QueryPartitionInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPartitionInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryPartitionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryReservationInfo(ctx context.Context, in *QueryReservationInfoRequest, opts ...grpc.CallOption) (*QueryReservationInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryReservationInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryReservationInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyTask(ctx context.Context, in *ModifyTaskRequest, opts ...grpc.CallOption) (*ModifyTaskReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyTaskReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyNode(ctx context.Context, in *ModifyCranedStateRequest, opts ...grpc.CallOption) (*ModifyCranedStateReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyCranedStateReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyPartitionAcl(ctx context.Context, in *ModifyPartitionAclRequest, opts ...grpc.CallOption) (*ModifyPartitionAclReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyPartitionAclReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyPartitionAcl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) EnableAutoPowerControl(ctx context.Context, in *EnableAutoPowerControlRequest, opts ...grpc.CallOption) (*EnableAutoPowerControlReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableAutoPowerControlReply)
	err := c.cc.Invoke(ctx, CraneCtld_EnableAutoPowerControl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyTasksExtraAttrs(ctx context.Context, in *ModifyTasksExtraAttrsRequest, opts ...grpc.CallOption) (*ModifyTasksExtraAttrsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyTasksExtraAttrsReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyTasksExtraAttrs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) AddAccount(ctx context.Context, in *AddAccountRequest, opts ...grpc.CallOption) (*AddAccountReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddAccountReply)
	err := c.cc.Invoke(ctx, CraneCtld_AddAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) AddUser(ctx context.Context, in *AddUserRequest, opts ...grpc.CallOption) (*AddUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_AddUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) AddQos(ctx context.Context, in *AddQosRequest, opts ...grpc.CallOption) (*AddQosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddQosReply)
	err := c.cc.Invoke(ctx, CraneCtld_AddQos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAccountReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteQos(ctx context.Context, in *DeleteQosRequest, opts ...grpc.CallOption) (*DeleteQosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteQosReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteQos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryAccountInfo(ctx context.Context, in *QueryAccountInfoRequest, opts ...grpc.CallOption) (*QueryAccountInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryAccountInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryAccountInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryUserInfo(ctx context.Context, in *QueryUserInfoRequest, opts ...grpc.CallOption) (*QueryUserInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUserInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryQosInfo(ctx context.Context, in *QueryQosInfoRequest, opts ...grpc.CallOption) (*QueryQosInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryQosInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryQosInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyAccount(ctx context.Context, in *ModifyAccountRequest, opts ...grpc.CallOption) (*ModifyAccountReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyAccountReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyUser(ctx context.Context, in *ModifyUserRequest, opts ...grpc.CallOption) (*ModifyUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ModifyQos(ctx context.Context, in *ModifyQosRequest, opts ...grpc.CallOption) (*ModifyQosReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModifyQosReply)
	err := c.cc.Invoke(ctx, CraneCtld_ModifyQos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) BlockAccountOrUser(ctx context.Context, in *BlockAccountOrUserRequest, opts ...grpc.CallOption) (*BlockAccountOrUserReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BlockAccountOrUserReply)
	err := c.cc.Invoke(ctx, CraneCtld_BlockAccountOrUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) ResetUserCredential(ctx context.Context, in *ResetUserCredentialRequest, opts ...grpc.CallOption) (*ResetUserCredentialReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetUserCredentialReply)
	err := c.cc.Invoke(ctx, CraneCtld_ResetUserCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryTxnLog(ctx context.Context, in *QueryTxnLogRequest, opts ...grpc.CallOption) (*QueryTxnLogReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTxnLogReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryTxnLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryClusterInfo(ctx context.Context, in *QueryClusterInfoRequest, opts ...grpc.CallOption) (*QueryClusterInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryClusterInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) QueryTasksInfo(ctx context.Context, in *QueryTasksInfoRequest, opts ...grpc.CallOption) (*QueryTasksInfoReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTasksInfoReply)
	err := c.cc.Invoke(ctx, CraneCtld_QueryTasksInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*CreateReservationReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReservationReply)
	err := c.cc.Invoke(ctx, CraneCtld_CreateReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) DeleteReservation(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*DeleteReservationReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteReservationReply)
	err := c.cc.Invoke(ctx, CraneCtld_DeleteReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) PowerStateChange(ctx context.Context, in *PowerStateChangeRequest, opts ...grpc.CallOption) (*PowerStateChangeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PowerStateChangeReply)
	err := c.cc.Invoke(ctx, CraneCtld_PowerStateChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldClient) SignUserCertificate(ctx context.Context, in *SignUserCertificateRequest, opts ...grpc.CallOption) (*SignUserCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignUserCertificateResponse)
	err := c.cc.Invoke(ctx, CraneCtld_SignUserCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CraneCtldServer is the server API for CraneCtld service.
// All implementations should embed UnimplementedCraneCtldServer
// for forward compatibility.
//
// Todo: Divide service into two parts: one for Craned and one for Crun
//
//	We need to distinguish the message sender
//	and have some kind of authentication
type CraneCtldServer interface {
	// RPCs called from ccancel
	CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskReply, error)
	// RPCs called from cbatch
	SubmitBatchTask(context.Context, *SubmitBatchTaskRequest) (*SubmitBatchTaskReply, error)
	SubmitBatchTasks(context.Context, *SubmitBatchTasksRequest) (*SubmitBatchTasksReply, error)
	// PRCs called from ccontrol
	QueryCranedInfo(context.Context, *QueryCranedInfoRequest) (*QueryCranedInfoReply, error)
	QueryPartitionInfo(context.Context, *QueryPartitionInfoRequest) (*QueryPartitionInfoReply, error)
	QueryReservationInfo(context.Context, *QueryReservationInfoRequest) (*QueryReservationInfoReply, error)
	ModifyTask(context.Context, *ModifyTaskRequest) (*ModifyTaskReply, error)
	ModifyNode(context.Context, *ModifyCranedStateRequest) (*ModifyCranedStateReply, error)
	ModifyPartitionAcl(context.Context, *ModifyPartitionAclRequest) (*ModifyPartitionAclReply, error)
	EnableAutoPowerControl(context.Context, *EnableAutoPowerControlRequest) (*EnableAutoPowerControlReply, error)
	ModifyTasksExtraAttrs(context.Context, *ModifyTasksExtraAttrsRequest) (*ModifyTasksExtraAttrsReply, error)
	// RPCs called from cacctmgr
	AddAccount(context.Context, *AddAccountRequest) (*AddAccountReply, error)
	AddUser(context.Context, *AddUserRequest) (*AddUserReply, error)
	AddQos(context.Context, *AddQosRequest) (*AddQosReply, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountReply, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserReply, error)
	DeleteQos(context.Context, *DeleteQosRequest) (*DeleteQosReply, error)
	QueryAccountInfo(context.Context, *QueryAccountInfoRequest) (*QueryAccountInfoReply, error)
	QueryUserInfo(context.Context, *QueryUserInfoRequest) (*QueryUserInfoReply, error)
	QueryQosInfo(context.Context, *QueryQosInfoRequest) (*QueryQosInfoReply, error)
	ModifyAccount(context.Context, *ModifyAccountRequest) (*ModifyAccountReply, error)
	ModifyUser(context.Context, *ModifyUserRequest) (*ModifyUserReply, error)
	ModifyQos(context.Context, *ModifyQosRequest) (*ModifyQosReply, error)
	BlockAccountOrUser(context.Context, *BlockAccountOrUserRequest) (*BlockAccountOrUserReply, error)
	ResetUserCredential(context.Context, *ResetUserCredentialRequest) (*ResetUserCredentialReply, error)
	QueryTxnLog(context.Context, *QueryTxnLogRequest) (*QueryTxnLogReply, error)
	// RPCs called from cinfo
	QueryClusterInfo(context.Context, *QueryClusterInfoRequest) (*QueryClusterInfoReply, error)
	// common RPCs
	QueryTasksInfo(context.Context, *QueryTasksInfoRequest) (*QueryTasksInfoReply, error)
	CreateReservation(context.Context, *CreateReservationRequest) (*CreateReservationReply, error)
	DeleteReservation(context.Context, *DeleteReservationRequest) (*DeleteReservationReply, error)
	// RPC called form plugin
	PowerStateChange(context.Context, *PowerStateChangeRequest) (*PowerStateChangeReply, error)
	// RPCS called from PKI request
	SignUserCertificate(context.Context, *SignUserCertificateRequest) (*SignUserCertificateResponse, error)
}

// UnimplementedCraneCtldServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCraneCtldServer struct{}

func (UnimplementedCraneCtldServer) CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTask not implemented")
}
func (UnimplementedCraneCtldServer) SubmitBatchTask(context.Context, *SubmitBatchTaskRequest) (*SubmitBatchTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatchTask not implemented")
}
func (UnimplementedCraneCtldServer) SubmitBatchTasks(context.Context, *SubmitBatchTasksRequest) (*SubmitBatchTasksReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBatchTasks not implemented")
}
func (UnimplementedCraneCtldServer) QueryCranedInfo(context.Context, *QueryCranedInfoRequest) (*QueryCranedInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCranedInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryPartitionInfo(context.Context, *QueryPartitionInfoRequest) (*QueryPartitionInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryPartitionInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryReservationInfo(context.Context, *QueryReservationInfoRequest) (*QueryReservationInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryReservationInfo not implemented")
}
func (UnimplementedCraneCtldServer) ModifyTask(context.Context, *ModifyTaskRequest) (*ModifyTaskReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyTask not implemented")
}
func (UnimplementedCraneCtldServer) ModifyNode(context.Context, *ModifyCranedStateRequest) (*ModifyCranedStateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyNode not implemented")
}
func (UnimplementedCraneCtldServer) ModifyPartitionAcl(context.Context, *ModifyPartitionAclRequest) (*ModifyPartitionAclReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyPartitionAcl not implemented")
}
func (UnimplementedCraneCtldServer) EnableAutoPowerControl(context.Context, *EnableAutoPowerControlRequest) (*EnableAutoPowerControlReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableAutoPowerControl not implemented")
}
func (UnimplementedCraneCtldServer) ModifyTasksExtraAttrs(context.Context, *ModifyTasksExtraAttrsRequest) (*ModifyTasksExtraAttrsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyTasksExtraAttrs not implemented")
}
func (UnimplementedCraneCtldServer) AddAccount(context.Context, *AddAccountRequest) (*AddAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAccount not implemented")
}
func (UnimplementedCraneCtldServer) AddUser(context.Context, *AddUserRequest) (*AddUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUser not implemented")
}
func (UnimplementedCraneCtldServer) AddQos(context.Context, *AddQosRequest) (*AddQosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddQos not implemented")
}
func (UnimplementedCraneCtldServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedCraneCtldServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedCraneCtldServer) DeleteQos(context.Context, *DeleteQosRequest) (*DeleteQosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQos not implemented")
}
func (UnimplementedCraneCtldServer) QueryAccountInfo(context.Context, *QueryAccountInfoRequest) (*QueryAccountInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAccountInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryUserInfo(context.Context, *QueryUserInfoRequest) (*QueryUserInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryQosInfo(context.Context, *QueryQosInfoRequest) (*QueryQosInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryQosInfo not implemented")
}
func (UnimplementedCraneCtldServer) ModifyAccount(context.Context, *ModifyAccountRequest) (*ModifyAccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyAccount not implemented")
}
func (UnimplementedCraneCtldServer) ModifyUser(context.Context, *ModifyUserRequest) (*ModifyUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyUser not implemented")
}
func (UnimplementedCraneCtldServer) ModifyQos(context.Context, *ModifyQosRequest) (*ModifyQosReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyQos not implemented")
}
func (UnimplementedCraneCtldServer) BlockAccountOrUser(context.Context, *BlockAccountOrUserRequest) (*BlockAccountOrUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockAccountOrUser not implemented")
}
func (UnimplementedCraneCtldServer) ResetUserCredential(context.Context, *ResetUserCredentialRequest) (*ResetUserCredentialReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetUserCredential not implemented")
}
func (UnimplementedCraneCtldServer) QueryTxnLog(context.Context, *QueryTxnLogRequest) (*QueryTxnLogReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTxnLog not implemented")
}
func (UnimplementedCraneCtldServer) QueryClusterInfo(context.Context, *QueryClusterInfoRequest) (*QueryClusterInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryClusterInfo not implemented")
}
func (UnimplementedCraneCtldServer) QueryTasksInfo(context.Context, *QueryTasksInfoRequest) (*QueryTasksInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTasksInfo not implemented")
}
func (UnimplementedCraneCtldServer) CreateReservation(context.Context, *CreateReservationRequest) (*CreateReservationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReservation not implemented")
}
func (UnimplementedCraneCtldServer) DeleteReservation(context.Context, *DeleteReservationRequest) (*DeleteReservationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReservation not implemented")
}
func (UnimplementedCraneCtldServer) PowerStateChange(context.Context, *PowerStateChangeRequest) (*PowerStateChangeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PowerStateChange not implemented")
}
func (UnimplementedCraneCtldServer) SignUserCertificate(context.Context, *SignUserCertificateRequest) (*SignUserCertificateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUserCertificate not implemented")
}
func (UnimplementedCraneCtldServer) testEmbeddedByValue() {}

// UnsafeCraneCtldServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CraneCtldServer will
// result in compilation errors.
type UnsafeCraneCtldServer interface {
	mustEmbedUnimplementedCraneCtldServer()
}

func RegisterCraneCtldServer(s grpc.ServiceRegistrar, srv CraneCtldServer) {
	// If the following call pancis, it indicates UnimplementedCraneCtldServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CraneCtld_ServiceDesc, srv)
}

func _CraneCtld_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_CancelTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).CancelTask(ctx, req.(*CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_SubmitBatchTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).SubmitBatchTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_SubmitBatchTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).SubmitBatchTask(ctx, req.(*SubmitBatchTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_SubmitBatchTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).SubmitBatchTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_SubmitBatchTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).SubmitBatchTasks(ctx, req.(*SubmitBatchTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryCranedInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCranedInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryCranedInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryCranedInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryCranedInfo(ctx, req.(*QueryCranedInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryPartitionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPartitionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryPartitionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryPartitionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryPartitionInfo(ctx, req.(*QueryPartitionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryReservationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReservationInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryReservationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryReservationInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryReservationInfo(ctx, req.(*QueryReservationInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyTask(ctx, req.(*ModifyTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyCranedStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyNode(ctx, req.(*ModifyCranedStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyPartitionAcl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyPartitionAclRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyPartitionAcl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyPartitionAcl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyPartitionAcl(ctx, req.(*ModifyPartitionAclRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_EnableAutoPowerControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableAutoPowerControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).EnableAutoPowerControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_EnableAutoPowerControl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).EnableAutoPowerControl(ctx, req.(*EnableAutoPowerControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyTasksExtraAttrs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyTasksExtraAttrsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyTasksExtraAttrs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyTasksExtraAttrs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyTasksExtraAttrs(ctx, req.(*ModifyTasksExtraAttrsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_AddAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).AddAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_AddAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).AddAccount(ctx, req.(*AddAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_AddUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).AddUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_AddUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).AddUser(ctx, req.(*AddUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_AddQos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddQosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).AddQos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_AddQos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).AddQos(ctx, req.(*AddQosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteQos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteQos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteQos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteQos(ctx, req.(*DeleteQosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAccountInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryAccountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryAccountInfo(ctx, req.(*QueryAccountInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryUserInfo(ctx, req.(*QueryUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryQosInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryQosInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryQosInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryQosInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryQosInfo(ctx, req.(*QueryQosInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyAccount(ctx, req.(*ModifyAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyUser(ctx, req.(*ModifyUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ModifyQos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyQosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ModifyQos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ModifyQos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ModifyQos(ctx, req.(*ModifyQosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_BlockAccountOrUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockAccountOrUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).BlockAccountOrUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_BlockAccountOrUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).BlockAccountOrUser(ctx, req.(*BlockAccountOrUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_ResetUserCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetUserCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).ResetUserCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_ResetUserCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).ResetUserCredential(ctx, req.(*ResetUserCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryTxnLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTxnLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryTxnLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryTxnLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryTxnLog(ctx, req.(*QueryTxnLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryClusterInfo(ctx, req.(*QueryClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_QueryTasksInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTasksInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).QueryTasksInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_QueryTasksInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).QueryTasksInfo(ctx, req.(*QueryTasksInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_CreateReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).CreateReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_CreateReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).CreateReservation(ctx, req.(*CreateReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_DeleteReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).DeleteReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_DeleteReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).DeleteReservation(ctx, req.(*DeleteReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_PowerStateChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerStateChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).PowerStateChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_PowerStateChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).PowerStateChange(ctx, req.(*PowerStateChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtld_SignUserCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignUserCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldServer).SignUserCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtld_SignUserCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldServer).SignUserCertificate(ctx, req.(*SignUserCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CraneCtld_ServiceDesc is the grpc.ServiceDesc for CraneCtld service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CraneCtld_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CraneCtld",
	HandlerType: (*CraneCtldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelTask",
			Handler:    _CraneCtld_CancelTask_Handler,
		},
		{
			MethodName: "SubmitBatchTask",
			Handler:    _CraneCtld_SubmitBatchTask_Handler,
		},
		{
			MethodName: "SubmitBatchTasks",
			Handler:    _CraneCtld_SubmitBatchTasks_Handler,
		},
		{
			MethodName: "QueryCranedInfo",
			Handler:    _CraneCtld_QueryCranedInfo_Handler,
		},
		{
			MethodName: "QueryPartitionInfo",
			Handler:    _CraneCtld_QueryPartitionInfo_Handler,
		},
		{
			MethodName: "QueryReservationInfo",
			Handler:    _CraneCtld_QueryReservationInfo_Handler,
		},
		{
			MethodName: "ModifyTask",
			Handler:    _CraneCtld_ModifyTask_Handler,
		},
		{
			MethodName: "ModifyNode",
			Handler:    _CraneCtld_ModifyNode_Handler,
		},
		{
			MethodName: "ModifyPartitionAcl",
			Handler:    _CraneCtld_ModifyPartitionAcl_Handler,
		},
		{
			MethodName: "EnableAutoPowerControl",
			Handler:    _CraneCtld_EnableAutoPowerControl_Handler,
		},
		{
			MethodName: "ModifyTasksExtraAttrs",
			Handler:    _CraneCtld_ModifyTasksExtraAttrs_Handler,
		},
		{
			MethodName: "AddAccount",
			Handler:    _CraneCtld_AddAccount_Handler,
		},
		{
			MethodName: "AddUser",
			Handler:    _CraneCtld_AddUser_Handler,
		},
		{
			MethodName: "AddQos",
			Handler:    _CraneCtld_AddQos_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _CraneCtld_DeleteAccount_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _CraneCtld_DeleteUser_Handler,
		},
		{
			MethodName: "DeleteQos",
			Handler:    _CraneCtld_DeleteQos_Handler,
		},
		{
			MethodName: "QueryAccountInfo",
			Handler:    _CraneCtld_QueryAccountInfo_Handler,
		},
		{
			MethodName: "QueryUserInfo",
			Handler:    _CraneCtld_QueryUserInfo_Handler,
		},
		{
			MethodName: "QueryQosInfo",
			Handler:    _CraneCtld_QueryQosInfo_Handler,
		},
		{
			MethodName: "ModifyAccount",
			Handler:    _CraneCtld_ModifyAccount_Handler,
		},
		{
			MethodName: "ModifyUser",
			Handler:    _CraneCtld_ModifyUser_Handler,
		},
		{
			MethodName: "ModifyQos",
			Handler:    _CraneCtld_ModifyQos_Handler,
		},
		{
			MethodName: "BlockAccountOrUser",
			Handler:    _CraneCtld_BlockAccountOrUser_Handler,
		},
		{
			MethodName: "ResetUserCredential",
			Handler:    _CraneCtld_ResetUserCredential_Handler,
		},
		{
			MethodName: "QueryTxnLog",
			Handler:    _CraneCtld_QueryTxnLog_Handler,
		},
		{
			MethodName: "QueryClusterInfo",
			Handler:    _CraneCtld_QueryClusterInfo_Handler,
		},
		{
			MethodName: "QueryTasksInfo",
			Handler:    _CraneCtld_QueryTasksInfo_Handler,
		},
		{
			MethodName: "CreateReservation",
			Handler:    _CraneCtld_CreateReservation_Handler,
		},
		{
			MethodName: "DeleteReservation",
			Handler:    _CraneCtld_DeleteReservation_Handler,
		},
		{
			MethodName: "PowerStateChange",
			Handler:    _CraneCtld_PowerStateChange_Handler,
		},
		{
			MethodName: "SignUserCertificate",
			Handler:    _CraneCtld_SignUserCertificate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Crane.proto",
}

const (
	CraneCtldForInternal_StepStatusChange_FullMethodName         = "/crane.grpc.CraneCtldForInternal/StepStatusChange"
	CraneCtldForInternal_CranedTriggerReverseConn_FullMethodName = "/crane.grpc.CraneCtldForInternal/CranedTriggerReverseConn"
	CraneCtldForInternal_CranedRegister_FullMethodName           = "/crane.grpc.CraneCtldForInternal/CranedRegister"
	CraneCtldForInternal_CranedPing_FullMethodName               = "/crane.grpc.CraneCtldForInternal/CranedPing"
	CraneCtldForInternal_CforedStream_FullMethodName             = "/crane.grpc.CraneCtldForInternal/CforedStream"
)

// CraneCtldForInternalClient is the client API for CraneCtldForInternal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CraneCtldForInternalClient interface {
	// RPCs called from Craned
	StepStatusChange(ctx context.Context, in *StepStatusChangeRequest, opts ...grpc.CallOption) (*StepStatusChangeReply, error)
	CranedTriggerReverseConn(ctx context.Context, in *CranedTriggerReverseConnRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CranedRegister(ctx context.Context, in *CranedRegisterRequest, opts ...grpc.CallOption) (*CranedRegisterReply, error)
	CranedPing(ctx context.Context, in *CranedPingRequest, opts ...grpc.CallOption) (*CranedPingReply, error)
	// RPCs called from Cfored
	CforedStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCforedRequest, StreamCtldReply], error)
}

type craneCtldForInternalClient struct {
	cc grpc.ClientConnInterface
}

func NewCraneCtldForInternalClient(cc grpc.ClientConnInterface) CraneCtldForInternalClient {
	return &craneCtldForInternalClient{cc}
}

func (c *craneCtldForInternalClient) StepStatusChange(ctx context.Context, in *StepStatusChangeRequest, opts ...grpc.CallOption) (*StepStatusChangeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StepStatusChangeReply)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_StepStatusChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CranedTriggerReverseConn(ctx context.Context, in *CranedTriggerReverseConnRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_CranedTriggerReverseConn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CranedRegister(ctx context.Context, in *CranedRegisterRequest, opts ...grpc.CallOption) (*CranedRegisterReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CranedRegisterReply)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_CranedRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CranedPing(ctx context.Context, in *CranedPingRequest, opts ...grpc.CallOption) (*CranedPingReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CranedPingReply)
	err := c.cc.Invoke(ctx, CraneCtldForInternal_CranedPing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *craneCtldForInternalClient) CforedStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCforedRequest, StreamCtldReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneCtldForInternal_ServiceDesc.Streams[0], CraneCtldForInternal_CforedStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCforedRequest, StreamCtldReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneCtldForInternal_CforedStreamClient = grpc.BidiStreamingClient[StreamCforedRequest, StreamCtldReply]

// CraneCtldForInternalServer is the server API for CraneCtldForInternal service.
// All implementations should embed UnimplementedCraneCtldForInternalServer
// for forward compatibility.
type CraneCtldForInternalServer interface {
	// RPCs called from Craned
	StepStatusChange(context.Context, *StepStatusChangeRequest) (*StepStatusChangeReply, error)
	CranedTriggerReverseConn(context.Context, *CranedTriggerReverseConnRequest) (*emptypb.Empty, error)
	CranedRegister(context.Context, *CranedRegisterRequest) (*CranedRegisterReply, error)
	CranedPing(context.Context, *CranedPingRequest) (*CranedPingReply, error)
	// RPCs called from Cfored
	CforedStream(grpc.BidiStreamingServer[StreamCforedRequest, StreamCtldReply]) error
}

// UnimplementedCraneCtldForInternalServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCraneCtldForInternalServer struct{}

func (UnimplementedCraneCtldForInternalServer) StepStatusChange(context.Context, *StepStatusChangeRequest) (*StepStatusChangeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StepStatusChange not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CranedTriggerReverseConn(context.Context, *CranedTriggerReverseConnRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CranedTriggerReverseConn not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CranedRegister(context.Context, *CranedRegisterRequest) (*CranedRegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CranedRegister not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CranedPing(context.Context, *CranedPingRequest) (*CranedPingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CranedPing not implemented")
}
func (UnimplementedCraneCtldForInternalServer) CforedStream(grpc.BidiStreamingServer[StreamCforedRequest, StreamCtldReply]) error {
	return status.Errorf(codes.Unimplemented, "method CforedStream not implemented")
}
func (UnimplementedCraneCtldForInternalServer) testEmbeddedByValue() {}

// UnsafeCraneCtldForInternalServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CraneCtldForInternalServer will
// result in compilation errors.
type UnsafeCraneCtldForInternalServer interface {
	mustEmbedUnimplementedCraneCtldForInternalServer()
}

func RegisterCraneCtldForInternalServer(s grpc.ServiceRegistrar, srv CraneCtldForInternalServer) {
	// If the following call pancis, it indicates UnimplementedCraneCtldForInternalServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CraneCtldForInternal_ServiceDesc, srv)
}

func _CraneCtldForInternal_StepStatusChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepStatusChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).StepStatusChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_StepStatusChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).StepStatusChange(ctx, req.(*StepStatusChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CranedTriggerReverseConn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CranedTriggerReverseConnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).CranedTriggerReverseConn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_CranedTriggerReverseConn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).CranedTriggerReverseConn(ctx, req.(*CranedTriggerReverseConnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CranedRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CranedRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).CranedRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_CranedRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).CranedRegister(ctx, req.(*CranedRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CranedPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CranedPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneCtldForInternalServer).CranedPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneCtldForInternal_CranedPing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneCtldForInternalServer).CranedPing(ctx, req.(*CranedPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CraneCtldForInternal_CforedStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneCtldForInternalServer).CforedStream(&grpc.GenericServerStream[StreamCforedRequest, StreamCtldReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneCtldForInternal_CforedStreamServer = grpc.BidiStreamingServer[StreamCforedRequest, StreamCtldReply]

// CraneCtldForInternal_ServiceDesc is the grpc.ServiceDesc for CraneCtldForInternal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CraneCtldForInternal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CraneCtldForInternal",
	HandlerType: (*CraneCtldForInternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StepStatusChange",
			Handler:    _CraneCtldForInternal_StepStatusChange_Handler,
		},
		{
			MethodName: "CranedTriggerReverseConn",
			Handler:    _CraneCtldForInternal_CranedTriggerReverseConn_Handler,
		},
		{
			MethodName: "CranedRegister",
			Handler:    _CraneCtldForInternal_CranedRegister_Handler,
		},
		{
			MethodName: "CranedPing",
			Handler:    _CraneCtldForInternal_CranedPing_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CforedStream",
			Handler:       _CraneCtldForInternal_CforedStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "Crane.proto",
}

const (
	Craned_Configure_FullMethodName                = "/crane.grpc.Craned/Configure"
	Craned_ExecuteSteps_FullMethodName             = "/crane.grpc.Craned/ExecuteSteps"
	Craned_CreateCgroupForJobs_FullMethodName      = "/crane.grpc.Craned/CreateCgroupForJobs"
	Craned_FreeSteps_FullMethodName                = "/crane.grpc.Craned/FreeSteps"
	Craned_ReleaseCgroupForJobs_FullMethodName     = "/crane.grpc.Craned/ReleaseCgroupForJobs"
	Craned_TerminateSteps_FullMethodName           = "/crane.grpc.Craned/TerminateSteps"
	Craned_TerminateOrphanedStep_FullMethodName    = "/crane.grpc.Craned/TerminateOrphanedStep"
	Craned_ChangeJobTimeLimit_FullMethodName       = "/crane.grpc.Craned/ChangeJobTimeLimit"
	Craned_QueryStepFromPort_FullMethodName        = "/crane.grpc.Craned/QueryStepFromPort"
	Craned_QuerySshStepEnvVariables_FullMethodName = "/crane.grpc.Craned/QuerySshStepEnvVariables"
	Craned_StepStatusChange_FullMethodName         = "/crane.grpc.Craned/StepStatusChange"
)

// CranedClient is the client API for Craned service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CranedClient interface {
	// ----------------------------------- Called from CraneCtld ----------------------------------------------------
	Configure(ctx context.Context, in *ConfigureCranedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ExecuteSteps(ctx context.Context, in *ExecuteStepsRequest, opts ...grpc.CallOption) (*ExecuteStepsReply, error)
	CreateCgroupForJobs(ctx context.Context, in *CreateCgroupForJobsRequest, opts ...grpc.CallOption) (*CreateCgroupForJobsReply, error)
	FreeSteps(ctx context.Context, in *FreeStepsRequest, opts ...grpc.CallOption) (*FreeStepsReply, error)
	ReleaseCgroupForJobs(ctx context.Context, in *ReleaseCgroupForJobsRequest, opts ...grpc.CallOption) (*ReleaseCgroupForJobsReply, error)
	//
	//If the task is an interactive task, the resource uuid is also revoked.
	//If there's no process in this interactive task, just deallocate all the resources.
	//If there are processes in this interactive task, kill all the processes and deallocate resources.
	//If the task is a batch task, just kill it.
	TerminateSteps(ctx context.Context, in *TerminateStepsRequest, opts ...grpc.CallOption) (*TerminateStepsReply, error)
	TerminateOrphanedStep(ctx context.Context, in *TerminateOrphanedStepRequest, opts ...grpc.CallOption) (*TerminateOrphanedStepReply, error)
	ChangeJobTimeLimit(ctx context.Context, in *ChangeJobTimeLimitRequest, opts ...grpc.CallOption) (*ChangeJobTimeLimitReply, error)
	// ----------------------------------- Called from Craned  ------------------------------------------------------
	QueryStepFromPort(ctx context.Context, in *QueryStepFromPortRequest, opts ...grpc.CallOption) (*QueryStepFromPortReply, error)
	QuerySshStepEnvVariables(ctx context.Context, in *QuerySshStepEnvVariablesRequest, opts ...grpc.CallOption) (*QuerySshStepEnvVariablesReply, error)
	// ----------------------------------- Called from Supervisor  ---------------------------------------------------
	StepStatusChange(ctx context.Context, in *StepStatusChangeRequest, opts ...grpc.CallOption) (*StepStatusChangeReply, error)
}

type cranedClient struct {
	cc grpc.ClientConnInterface
}

func NewCranedClient(cc grpc.ClientConnInterface) CranedClient {
	return &cranedClient{cc}
}

func (c *cranedClient) Configure(ctx context.Context, in *ConfigureCranedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Craned_Configure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) ExecuteSteps(ctx context.Context, in *ExecuteStepsRequest, opts ...grpc.CallOption) (*ExecuteStepsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteStepsReply)
	err := c.cc.Invoke(ctx, Craned_ExecuteSteps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) CreateCgroupForJobs(ctx context.Context, in *CreateCgroupForJobsRequest, opts ...grpc.CallOption) (*CreateCgroupForJobsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCgroupForJobsReply)
	err := c.cc.Invoke(ctx, Craned_CreateCgroupForJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) FreeSteps(ctx context.Context, in *FreeStepsRequest, opts ...grpc.CallOption) (*FreeStepsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FreeStepsReply)
	err := c.cc.Invoke(ctx, Craned_FreeSteps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) ReleaseCgroupForJobs(ctx context.Context, in *ReleaseCgroupForJobsRequest, opts ...grpc.CallOption) (*ReleaseCgroupForJobsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseCgroupForJobsReply)
	err := c.cc.Invoke(ctx, Craned_ReleaseCgroupForJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) TerminateSteps(ctx context.Context, in *TerminateStepsRequest, opts ...grpc.CallOption) (*TerminateStepsReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateStepsReply)
	err := c.cc.Invoke(ctx, Craned_TerminateSteps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) TerminateOrphanedStep(ctx context.Context, in *TerminateOrphanedStepRequest, opts ...grpc.CallOption) (*TerminateOrphanedStepReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminateOrphanedStepReply)
	err := c.cc.Invoke(ctx, Craned_TerminateOrphanedStep_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) ChangeJobTimeLimit(ctx context.Context, in *ChangeJobTimeLimitRequest, opts ...grpc.CallOption) (*ChangeJobTimeLimitReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeJobTimeLimitReply)
	err := c.cc.Invoke(ctx, Craned_ChangeJobTimeLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) QueryStepFromPort(ctx context.Context, in *QueryStepFromPortRequest, opts ...grpc.CallOption) (*QueryStepFromPortReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryStepFromPortReply)
	err := c.cc.Invoke(ctx, Craned_QueryStepFromPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) QuerySshStepEnvVariables(ctx context.Context, in *QuerySshStepEnvVariablesRequest, opts ...grpc.CallOption) (*QuerySshStepEnvVariablesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySshStepEnvVariablesReply)
	err := c.cc.Invoke(ctx, Craned_QuerySshStepEnvVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedClient) StepStatusChange(ctx context.Context, in *StepStatusChangeRequest, opts ...grpc.CallOption) (*StepStatusChangeReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StepStatusChangeReply)
	err := c.cc.Invoke(ctx, Craned_StepStatusChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CranedServer is the server API for Craned service.
// All implementations should embed UnimplementedCranedServer
// for forward compatibility.
type CranedServer interface {
	// ----------------------------------- Called from CraneCtld ----------------------------------------------------
	Configure(context.Context, *ConfigureCranedRequest) (*emptypb.Empty, error)
	ExecuteSteps(context.Context, *ExecuteStepsRequest) (*ExecuteStepsReply, error)
	CreateCgroupForJobs(context.Context, *CreateCgroupForJobsRequest) (*CreateCgroupForJobsReply, error)
	FreeSteps(context.Context, *FreeStepsRequest) (*FreeStepsReply, error)
	ReleaseCgroupForJobs(context.Context, *ReleaseCgroupForJobsRequest) (*ReleaseCgroupForJobsReply, error)
	//
	//If the task is an interactive task, the resource uuid is also revoked.
	//If there's no process in this interactive task, just deallocate all the resources.
	//If there are processes in this interactive task, kill all the processes and deallocate resources.
	//If the task is a batch task, just kill it.
	TerminateSteps(context.Context, *TerminateStepsRequest) (*TerminateStepsReply, error)
	TerminateOrphanedStep(context.Context, *TerminateOrphanedStepRequest) (*TerminateOrphanedStepReply, error)
	ChangeJobTimeLimit(context.Context, *ChangeJobTimeLimitRequest) (*ChangeJobTimeLimitReply, error)
	// ----------------------------------- Called from Craned  ------------------------------------------------------
	QueryStepFromPort(context.Context, *QueryStepFromPortRequest) (*QueryStepFromPortReply, error)
	QuerySshStepEnvVariables(context.Context, *QuerySshStepEnvVariablesRequest) (*QuerySshStepEnvVariablesReply, error)
	// ----------------------------------- Called from Supervisor  ---------------------------------------------------
	StepStatusChange(context.Context, *StepStatusChangeRequest) (*StepStatusChangeReply, error)
}

// UnimplementedCranedServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCranedServer struct{}

func (UnimplementedCranedServer) Configure(context.Context, *ConfigureCranedRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (UnimplementedCranedServer) ExecuteSteps(context.Context, *ExecuteStepsRequest) (*ExecuteStepsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSteps not implemented")
}
func (UnimplementedCranedServer) CreateCgroupForJobs(context.Context, *CreateCgroupForJobsRequest) (*CreateCgroupForJobsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCgroupForJobs not implemented")
}
func (UnimplementedCranedServer) FreeSteps(context.Context, *FreeStepsRequest) (*FreeStepsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FreeSteps not implemented")
}
func (UnimplementedCranedServer) ReleaseCgroupForJobs(context.Context, *ReleaseCgroupForJobsRequest) (*ReleaseCgroupForJobsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseCgroupForJobs not implemented")
}
func (UnimplementedCranedServer) TerminateSteps(context.Context, *TerminateStepsRequest) (*TerminateStepsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateSteps not implemented")
}
func (UnimplementedCranedServer) TerminateOrphanedStep(context.Context, *TerminateOrphanedStepRequest) (*TerminateOrphanedStepReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateOrphanedStep not implemented")
}
func (UnimplementedCranedServer) ChangeJobTimeLimit(context.Context, *ChangeJobTimeLimitRequest) (*ChangeJobTimeLimitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeJobTimeLimit not implemented")
}
func (UnimplementedCranedServer) QueryStepFromPort(context.Context, *QueryStepFromPortRequest) (*QueryStepFromPortReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStepFromPort not implemented")
}
func (UnimplementedCranedServer) QuerySshStepEnvVariables(context.Context, *QuerySshStepEnvVariablesRequest) (*QuerySshStepEnvVariablesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySshStepEnvVariables not implemented")
}
func (UnimplementedCranedServer) StepStatusChange(context.Context, *StepStatusChangeRequest) (*StepStatusChangeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StepStatusChange not implemented")
}
func (UnimplementedCranedServer) testEmbeddedByValue() {}

// UnsafeCranedServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CranedServer will
// result in compilation errors.
type UnsafeCranedServer interface {
	mustEmbedUnimplementedCranedServer()
}

func RegisterCranedServer(s grpc.ServiceRegistrar, srv CranedServer) {
	// If the following call pancis, it indicates UnimplementedCranedServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Craned_ServiceDesc, srv)
}

func _Craned_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureCranedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_Configure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).Configure(ctx, req.(*ConfigureCranedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_ExecuteSteps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteStepsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).ExecuteSteps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_ExecuteSteps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).ExecuteSteps(ctx, req.(*ExecuteStepsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_CreateCgroupForJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCgroupForJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).CreateCgroupForJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_CreateCgroupForJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).CreateCgroupForJobs(ctx, req.(*CreateCgroupForJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_FreeSteps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreeStepsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).FreeSteps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_FreeSteps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).FreeSteps(ctx, req.(*FreeStepsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_ReleaseCgroupForJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseCgroupForJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).ReleaseCgroupForJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_ReleaseCgroupForJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).ReleaseCgroupForJobs(ctx, req.(*ReleaseCgroupForJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_TerminateSteps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateStepsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).TerminateSteps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_TerminateSteps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).TerminateSteps(ctx, req.(*TerminateStepsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_TerminateOrphanedStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateOrphanedStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).TerminateOrphanedStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_TerminateOrphanedStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).TerminateOrphanedStep(ctx, req.(*TerminateOrphanedStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_ChangeJobTimeLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeJobTimeLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).ChangeJobTimeLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_ChangeJobTimeLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).ChangeJobTimeLimit(ctx, req.(*ChangeJobTimeLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_QueryStepFromPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStepFromPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).QueryStepFromPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_QueryStepFromPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).QueryStepFromPort(ctx, req.(*QueryStepFromPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_QuerySshStepEnvVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySshStepEnvVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).QuerySshStepEnvVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_QuerySshStepEnvVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).QuerySshStepEnvVariables(ctx, req.(*QuerySshStepEnvVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Craned_StepStatusChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StepStatusChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedServer).StepStatusChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Craned_StepStatusChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedServer).StepStatusChange(ctx, req.(*StepStatusChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Craned_ServiceDesc is the grpc.ServiceDesc for Craned service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Craned_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.Craned",
	HandlerType: (*CranedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Configure",
			Handler:    _Craned_Configure_Handler,
		},
		{
			MethodName: "ExecuteSteps",
			Handler:    _Craned_ExecuteSteps_Handler,
		},
		{
			MethodName: "CreateCgroupForJobs",
			Handler:    _Craned_CreateCgroupForJobs_Handler,
		},
		{
			MethodName: "FreeSteps",
			Handler:    _Craned_FreeSteps_Handler,
		},
		{
			MethodName: "ReleaseCgroupForJobs",
			Handler:    _Craned_ReleaseCgroupForJobs_Handler,
		},
		{
			MethodName: "TerminateSteps",
			Handler:    _Craned_TerminateSteps_Handler,
		},
		{
			MethodName: "TerminateOrphanedStep",
			Handler:    _Craned_TerminateOrphanedStep_Handler,
		},
		{
			MethodName: "ChangeJobTimeLimit",
			Handler:    _Craned_ChangeJobTimeLimit_Handler,
		},
		{
			MethodName: "QueryStepFromPort",
			Handler:    _Craned_QueryStepFromPort_Handler,
		},
		{
			MethodName: "QuerySshStepEnvVariables",
			Handler:    _Craned_QuerySshStepEnvVariables_Handler,
		},
		{
			MethodName: "StepStatusChange",
			Handler:    _Craned_StepStatusChange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Crane.proto",
}

const (
	CranedForPam_QueryStepFromPortForward_FullMethodName        = "/crane.grpc.CranedForPam/QueryStepFromPortForward"
	CranedForPam_MigrateSshProcToCgroup_FullMethodName          = "/crane.grpc.CranedForPam/MigrateSshProcToCgroup"
	CranedForPam_QuerySshStepEnvVariablesForward_FullMethodName = "/crane.grpc.CranedForPam/QuerySshStepEnvVariablesForward"
)

// CranedForPamClient is the client API for CranedForPam service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CranedForPamClient interface {
	// ----------------------------------- Called from Pam Module  ---------------------------------------------------
	QueryStepFromPortForward(ctx context.Context, in *QueryStepFromPortForwardRequest, opts ...grpc.CallOption) (*QueryStepFromPortForwardReply, error)
	MigrateSshProcToCgroup(ctx context.Context, in *MigrateSshProcToCgroupRequest, opts ...grpc.CallOption) (*MigrateSshProcToCgroupReply, error)
	QuerySshStepEnvVariablesForward(ctx context.Context, in *QuerySshStepEnvVariablesForwardRequest, opts ...grpc.CallOption) (*QuerySshStepEnvVariablesForwardReply, error)
}

type cranedForPamClient struct {
	cc grpc.ClientConnInterface
}

func NewCranedForPamClient(cc grpc.ClientConnInterface) CranedForPamClient {
	return &cranedForPamClient{cc}
}

func (c *cranedForPamClient) QueryStepFromPortForward(ctx context.Context, in *QueryStepFromPortForwardRequest, opts ...grpc.CallOption) (*QueryStepFromPortForwardReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryStepFromPortForwardReply)
	err := c.cc.Invoke(ctx, CranedForPam_QueryStepFromPortForward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedForPamClient) MigrateSshProcToCgroup(ctx context.Context, in *MigrateSshProcToCgroupRequest, opts ...grpc.CallOption) (*MigrateSshProcToCgroupReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateSshProcToCgroupReply)
	err := c.cc.Invoke(ctx, CranedForPam_MigrateSshProcToCgroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cranedForPamClient) QuerySshStepEnvVariablesForward(ctx context.Context, in *QuerySshStepEnvVariablesForwardRequest, opts ...grpc.CallOption) (*QuerySshStepEnvVariablesForwardReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySshStepEnvVariablesForwardReply)
	err := c.cc.Invoke(ctx, CranedForPam_QuerySshStepEnvVariablesForward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CranedForPamServer is the server API for CranedForPam service.
// All implementations should embed UnimplementedCranedForPamServer
// for forward compatibility.
type CranedForPamServer interface {
	// ----------------------------------- Called from Pam Module  ---------------------------------------------------
	QueryStepFromPortForward(context.Context, *QueryStepFromPortForwardRequest) (*QueryStepFromPortForwardReply, error)
	MigrateSshProcToCgroup(context.Context, *MigrateSshProcToCgroupRequest) (*MigrateSshProcToCgroupReply, error)
	QuerySshStepEnvVariablesForward(context.Context, *QuerySshStepEnvVariablesForwardRequest) (*QuerySshStepEnvVariablesForwardReply, error)
}

// UnimplementedCranedForPamServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCranedForPamServer struct{}

func (UnimplementedCranedForPamServer) QueryStepFromPortForward(context.Context, *QueryStepFromPortForwardRequest) (*QueryStepFromPortForwardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStepFromPortForward not implemented")
}
func (UnimplementedCranedForPamServer) MigrateSshProcToCgroup(context.Context, *MigrateSshProcToCgroupRequest) (*MigrateSshProcToCgroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateSshProcToCgroup not implemented")
}
func (UnimplementedCranedForPamServer) QuerySshStepEnvVariablesForward(context.Context, *QuerySshStepEnvVariablesForwardRequest) (*QuerySshStepEnvVariablesForwardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySshStepEnvVariablesForward not implemented")
}
func (UnimplementedCranedForPamServer) testEmbeddedByValue() {}

// UnsafeCranedForPamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CranedForPamServer will
// result in compilation errors.
type UnsafeCranedForPamServer interface {
	mustEmbedUnimplementedCranedForPamServer()
}

func RegisterCranedForPamServer(s grpc.ServiceRegistrar, srv CranedForPamServer) {
	// If the following call pancis, it indicates UnimplementedCranedForPamServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CranedForPam_ServiceDesc, srv)
}

func _CranedForPam_QueryStepFromPortForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStepFromPortForwardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedForPamServer).QueryStepFromPortForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CranedForPam_QueryStepFromPortForward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedForPamServer).QueryStepFromPortForward(ctx, req.(*QueryStepFromPortForwardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CranedForPam_MigrateSshProcToCgroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateSshProcToCgroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedForPamServer).MigrateSshProcToCgroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CranedForPam_MigrateSshProcToCgroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedForPamServer).MigrateSshProcToCgroup(ctx, req.(*MigrateSshProcToCgroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CranedForPam_QuerySshStepEnvVariablesForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySshStepEnvVariablesForwardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CranedForPamServer).QuerySshStepEnvVariablesForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CranedForPam_QuerySshStepEnvVariablesForward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CranedForPamServer).QuerySshStepEnvVariablesForward(ctx, req.(*QuerySshStepEnvVariablesForwardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CranedForPam_ServiceDesc is the grpc.ServiceDesc for CranedForPam service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CranedForPam_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CranedForPam",
	HandlerType: (*CranedForPamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryStepFromPortForward",
			Handler:    _CranedForPam_QueryStepFromPortForward_Handler,
		},
		{
			MethodName: "MigrateSshProcToCgroup",
			Handler:    _CranedForPam_MigrateSshProcToCgroup_Handler,
		},
		{
			MethodName: "QuerySshStepEnvVariablesForward",
			Handler:    _CranedForPam_QuerySshStepEnvVariablesForward_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Crane.proto",
}

const (
	CraneForeD_CallocStream_FullMethodName      = "/crane.grpc.CraneForeD/CallocStream"
	CraneForeD_CrunStream_FullMethodName        = "/crane.grpc.CraneForeD/CrunStream"
	CraneForeD_TaskIOStream_FullMethodName      = "/crane.grpc.CraneForeD/TaskIOStream"
	CraneForeD_QueryStepFromPort_FullMethodName = "/crane.grpc.CraneForeD/QueryStepFromPort"
)

// CraneForeDClient is the client API for CraneForeD service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CraneForeDClient interface {
	CallocStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCallocRequest, StreamCallocReply], error)
	CrunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCrunRequest, StreamCrunReply], error)
	TaskIOStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamTaskIORequest, StreamTaskIOReply], error)
	QueryStepFromPort(ctx context.Context, in *QueryStepFromPortRequest, opts ...grpc.CallOption) (*QueryStepFromPortReply, error)
}

type craneForeDClient struct {
	cc grpc.ClientConnInterface
}

func NewCraneForeDClient(cc grpc.ClientConnInterface) CraneForeDClient {
	return &craneForeDClient{cc}
}

func (c *craneForeDClient) CallocStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCallocRequest, StreamCallocReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneForeD_ServiceDesc.Streams[0], CraneForeD_CallocStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCallocRequest, StreamCallocReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CallocStreamClient = grpc.BidiStreamingClient[StreamCallocRequest, StreamCallocReply]

func (c *craneForeDClient) CrunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamCrunRequest, StreamCrunReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneForeD_ServiceDesc.Streams[1], CraneForeD_CrunStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCrunRequest, StreamCrunReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CrunStreamClient = grpc.BidiStreamingClient[StreamCrunRequest, StreamCrunReply]

func (c *craneForeDClient) TaskIOStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamTaskIORequest, StreamTaskIOReply], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CraneForeD_ServiceDesc.Streams[2], CraneForeD_TaskIOStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamTaskIORequest, StreamTaskIOReply]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_TaskIOStreamClient = grpc.BidiStreamingClient[StreamTaskIORequest, StreamTaskIOReply]

func (c *craneForeDClient) QueryStepFromPort(ctx context.Context, in *QueryStepFromPortRequest, opts ...grpc.CallOption) (*QueryStepFromPortReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryStepFromPortReply)
	err := c.cc.Invoke(ctx, CraneForeD_QueryStepFromPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CraneForeDServer is the server API for CraneForeD service.
// All implementations should embed UnimplementedCraneForeDServer
// for forward compatibility.
type CraneForeDServer interface {
	CallocStream(grpc.BidiStreamingServer[StreamCallocRequest, StreamCallocReply]) error
	CrunStream(grpc.BidiStreamingServer[StreamCrunRequest, StreamCrunReply]) error
	TaskIOStream(grpc.BidiStreamingServer[StreamTaskIORequest, StreamTaskIOReply]) error
	QueryStepFromPort(context.Context, *QueryStepFromPortRequest) (*QueryStepFromPortReply, error)
}

// UnimplementedCraneForeDServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCraneForeDServer struct{}

func (UnimplementedCraneForeDServer) CallocStream(grpc.BidiStreamingServer[StreamCallocRequest, StreamCallocReply]) error {
	return status.Errorf(codes.Unimplemented, "method CallocStream not implemented")
}
func (UnimplementedCraneForeDServer) CrunStream(grpc.BidiStreamingServer[StreamCrunRequest, StreamCrunReply]) error {
	return status.Errorf(codes.Unimplemented, "method CrunStream not implemented")
}
func (UnimplementedCraneForeDServer) TaskIOStream(grpc.BidiStreamingServer[StreamTaskIORequest, StreamTaskIOReply]) error {
	return status.Errorf(codes.Unimplemented, "method TaskIOStream not implemented")
}
func (UnimplementedCraneForeDServer) QueryStepFromPort(context.Context, *QueryStepFromPortRequest) (*QueryStepFromPortReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStepFromPort not implemented")
}
func (UnimplementedCraneForeDServer) testEmbeddedByValue() {}

// UnsafeCraneForeDServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CraneForeDServer will
// result in compilation errors.
type UnsafeCraneForeDServer interface {
	mustEmbedUnimplementedCraneForeDServer()
}

func RegisterCraneForeDServer(s grpc.ServiceRegistrar, srv CraneForeDServer) {
	// If the following call pancis, it indicates UnimplementedCraneForeDServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CraneForeD_ServiceDesc, srv)
}

func _CraneForeD_CallocStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneForeDServer).CallocStream(&grpc.GenericServerStream[StreamCallocRequest, StreamCallocReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CallocStreamServer = grpc.BidiStreamingServer[StreamCallocRequest, StreamCallocReply]

func _CraneForeD_CrunStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneForeDServer).CrunStream(&grpc.GenericServerStream[StreamCrunRequest, StreamCrunReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_CrunStreamServer = grpc.BidiStreamingServer[StreamCrunRequest, StreamCrunReply]

func _CraneForeD_TaskIOStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CraneForeDServer).TaskIOStream(&grpc.GenericServerStream[StreamTaskIORequest, StreamTaskIOReply]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CraneForeD_TaskIOStreamServer = grpc.BidiStreamingServer[StreamTaskIORequest, StreamTaskIOReply]

func _CraneForeD_QueryStepFromPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStepFromPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CraneForeDServer).QueryStepFromPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CraneForeD_QueryStepFromPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CraneForeDServer).QueryStepFromPort(ctx, req.(*QueryStepFromPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CraneForeD_ServiceDesc is the grpc.ServiceDesc for CraneForeD service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CraneForeD_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crane.grpc.CraneForeD",
	HandlerType: (*CraneForeDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryStepFromPort",
			Handler:    _CraneForeD_QueryStepFromPort_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CallocStream",
			Handler:       _CraneForeD_CallocStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CrunStream",
			Handler:       _CraneForeD_CrunStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TaskIOStream",
			Handler:       _CraneForeD_TaskIOStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "Crane.proto",
}
